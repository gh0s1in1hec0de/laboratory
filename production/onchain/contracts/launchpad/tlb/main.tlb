// TODO ADD `OP` FIELDS WITH ACTUAL CRC32 HASHES IN CONSTRUCTOR TAG
// TOKEN LAUNCHER
sale_data# creator_limit_pct:uint8 creator_balance:Coins creator_token_price:uint32 creator_round_end_time:int32
           wl_tokens_share:uint8 wl_ton_limit_pct:uint8 wl_ton_invested_total:Coins wl_round_end_time:int32
           public_synthetic_reserve_a:Coins public_synthetic_reserve_b:Coins public_round_end_time:int32 = SaleData;
storage# is_initialized:int1 total_supply:Coins cur_balance:Coins
         chief:MsgAddressInt creator: MsgAddressInt
         sale_data: ^SaleData metadata_uri: ^Cell = LaunchStorage;

init# token_launch_fut_jet_wallet_address:MsgAddressInt util_jet_wallet_address:MsgAddressInt = Initialize;
owner_buyout# query_id:uint64 = LauchIncomingMessage;
public_buy# query_id:uint64 = LauchIncomingMessage;

// REFUNDS AND CLAIMS
// There is two global operations - refund and claim. Seems like splitting logic for this two entities is the
// best way to handle this two mechanics the most safe and concise way.
refund_request# query_id:uint64 mode:uint4 maybe_tons:Coins = WithdrawFundsRequest;
claim_request# query_id:uint64 = WithdrawFundsRequest;

// In fact they are the same
refund_confirmation# query_id:uint64 wl_tons:Coins pub_tons:Coins jettons:Coins to:MsgAddressInt = WithdrawFundsResponse;
claim_confirmation# query_id:uint64 wl_tons:Coins pub_tons:Coins jettons:Coins to:MsgAddressInt = WithdrawFundsResponse;

// USER VAULT
storage# owner:MsgAddressInt wl_invested:Coins public_invested:Coins token_balance:Coins = UserVaultStorage;

balance_update# query_id:uint64 mode:uint4 tons:Coins fut_jettons:Coins = BalanceUpdate;
wl_callback# query_id:uint64 should_burn:int1 owner:MsgAddressInt = WlCallback;