#include "../../stdlib.fc";
#include "../op-codes.fc";
#include "../utils.fc";
#include "../gas.fc";

#include "tl_context.fc";
#include "trades_handler.fc";

const int MINT_QUERY_ID = 27082006;

() deploy_launch_jetton() inline {
    (cell jetton_master_stateinit, slice jetton_master_address) = calculate_fut_jet_master_data(
        jet_tools::const::fut_jet_master_code,
        this::const::fut_jet_total_supply,
        my_address(),
        address_none(),
        jet_tools::const::wallet_code,
        jet_tools::const::metadata
    );

    ;; Internal message for jetton master jetton wallet
    cell master_msg = begin_cell()
        .store_op(op::internal_transfer)
        .store_query_id(MINT_QUERY_ID)
        .store_coins(this::const::fut_jet_total_supply)
        .store_slice(my_address()) ;; from
        .store_slice(my_address()) ;; response_address
        .store_coins(1) ;; Forwarding 1 nanoton to get transfer_notification
        .store_int(0, 1) ;; store one-bit zero to avoint exit code 9 by TVM
        .end_cell();
    cell msg_body = begin_cell()
        .store_op(op::mint)
        .store_query_id(MINT_QUERY_ID)
        .store_slice(my_address())
        .store_coins(JETTON_MIN_TRANSFER_FEE)
        .store_ref(master_msg)
        .end_cell();
    cell msg = begin_cell()
        .store_msg_flags_and_address_none(BOUNCEABLE)
        .store_slice(jetton_master_address)
        .store_coins(JETTON_MIN_TRANSFER_FEE + 111) ;; TODO Should we calculate computational fee for op::mint?
        .store_statinit_ref_and_body_ref(jetton_master_stateinit, msg_body)
        .end_cell();
    send_raw_message(msg, SEND_MODE_BOUNCE_ON_ACTION_FAIL);
}

() route_incoming_transfer(int query_id, int attached_value, slice sender_address, int jetton_amount, slice initiator, slice maybe_payload) impure inline {
    if (equal_slices_bits(sender_address, jet_tools::const::util_jet_wallet_address)) {
        int util_jet_enr_mode = maybe_payload~load_uint(UTIL_JET_SEND_MODE_SIZE);

        if (util_jet_enr_mode == UTIL_JET_REWARD_ENROLLMENT) {
            ;; It does mean, that utility jettons reward amount was already enrolled
            if(this::reward_util_jets_cur_balance != 0 | this::const::reward_util_jets_total_amount != 0) {
                cell chargeback_msg = build_jetton_transfer_msg(query_id, 0, jetton_amount, jet_tools::const::util_jet_wallet_address, initiator, 1, NO_MODE);
                send_raw_message(chargeback_msg, SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE | SEND_MODE_IGNORE_ERRORS);
                return ();
            }
            this::const::reward_util_jets_total_amount += jetton_amount;
            this::reward_util_jets_cur_balance += jetton_amount;
        }

        if (util_jet_enr_mode == UTIL_JET_WL_PASS) {
            if(jetton_amount < wl_round::const::pass_util_jet_amount) {
                cell chargeback_msg = build_jetton_transfer_msg(query_id, 0, jetton_amount, jet_tools::const::util_jet_wallet_address, initiator, 1, NO_MODE);
                send_raw_message(chargeback_msg, SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE | SEND_MODE_IGNORE_ERRORS);
                return ();
            }
            handle_wl_purchase(query_id, attached_value, sender_address, initiator);
        }
    }
    ;; `ifs` oreder defined this way for reasons of efficiency
    if (jetton_amount == this::const::fut_jet_total_supply) {
        if (~ equal_slices_bits(sender_address, sale_state::const::fut_jet_wallet_address)) {
            ;; It does mean we just got random tokens on equal amount
            return ();
        }
        sale_state::const::fut_jet_deployed_balance = this::const::fut_jet_total_supply;
        ;; TODO Send dex share and platform share to chief & revoke contarct ownership
        ;; I think it will be ok to revoke contract ownership in asynccronous manner and just wait confirmation on backend side :)
        ;; Fuck TON :)))
    }
}