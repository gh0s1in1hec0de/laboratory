#include "../../stdlib.fc";
#include "../op-codes.fc";
#include "../utils.fc";
#include "../gas.fc";

#include "tl_context.fc";
#include "trades_handler.fc";

const int MINT_QUERY_ID = 27082006;

() deploy_launch_jetton() inline {
    (cell jetton_master_stateinit, slice jetton_master_address) = calculate_fut_jet_master_data(
        tools::const::fut_jet_master_code,
        config::const::fut_jet_total_supply,
        my_address(),
        address_none(),
        tools::const::wallet_code,
        tools::const::metadata
    );
    ;; Internal message for jetton master jetton wallet
    cell master_msg = begin_cell()
        .store_op(op::internal_transfer)
        .store_query_id(MINT_QUERY_ID)
        .store_coins(config::const::fut_jet_total_supply)
        .store_slice(my_address()) ;; from
        .store_slice(my_address()) ;; response_address
        .store_coins(1) ;; Forwarding 1 nanoton to get transfer_notification
        .store_int(0, 1) ;; store one-bit zero to avoint exit code 9 by TVM
        .end_cell();
    cell msg_body = begin_cell()
        .store_op(op::mint)
        .store_query_id(MINT_QUERY_ID)
        .store_slice(my_address())
        .store_coins(JETTON_MIN_TRANSFER_FEE)
        .store_ref(master_msg)
        .end_cell();
    cell msg = begin_cell()
        .store_msg_flags_and_address_none(BOUNCEABLE)
        .store_slice(jetton_master_address)
        .store_coins(get_jetton_deploy_gas_cost())
        .store_statinit_ref_and_body_ref(jetton_master_stateinit, msg_body)
        .end_cell();
    send_raw_message(msg, SEND_MODE_BOUNCE_ON_ACTION_FAIL);
}

() route_incoming_transfer(int query_id, int attached_value, slice sender_address, int jetton_amount, slice initiator, slice maybe_payload) impure inline {
    ;; CN: check sender address
    if (equal_slices_bits(sender_address, tools::const::util_jet_wallet_address)) {
        raw_reserve(0, RESERVE_WITH_CONTRACT_BALANCE);
        int util_jet_enr_mode = maybe_payload~load_uint(UTIL_JET_SEND_MODE_SIZE);

        ;; CN: number of tokens required for reward
        if (util_jet_enr_mode == UTIL_JET_REWARD_ENROLLMENT) {
            ;; It does mean, that utility jettons reward amount was already enrolled
            if(general_state::reward_util_jets_balance != 0 | config::const::reward_util_jets_total_amount != 0) {
                cell chargeback_msg = build_jetton_transfer_msg(
                    query_id,
                    0,
                    jetton_amount,
                    tools::const::util_jet_wallet_address,
                    initiator,
                    1,
                    begin_cell().store_uint(0, 1)
                );
                send_raw_message(chargeback_msg, SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE | SEND_MODE_IGNORE_ERRORS);
                return ();
            }
            config::const::reward_util_jets_total_amount += jetton_amount;
            general_state::reward_util_jets_balance += jetton_amount;
        }

        ;; CN: number of tokens required for wl purchase
        if (util_jet_enr_mode == UTIL_JET_WL_PASS) {
            if(jetton_amount < wl_round::const::pass_util_jet_amount) {
                cell chargeback_msg = build_jetton_transfer_msg(
                    query_id,
                    0,
                    jetton_amount,
                    tools::const::util_jet_wallet_address,
                    initiator,
                    1,
                    begin_cell().store_uint(0, 1)
                );
                send_raw_message(chargeback_msg, SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE | SEND_MODE_IGNORE_ERRORS);
                return ();
            }
            handle_wl_purchase(query_id, attached_value, sender_address, initiator);
        }
    }
    ;; `ifs` oreder defined this way for reasons of efficiency
    ;; CN: deploy jet
    if (jetton_amount == config::const::fut_jet_total_supply) {
        if (~ equal_slices_bits(sender_address, tools::const::fut_jet_wallet_address)) {
            ;; It does mean we just got random tokens on equal amount
            return ();
        }
        general_state::fut_jet_deployed_balance = config::const::fut_jet_total_supply;

        ;; We send one jetton transfer with all the
        cell transfer_msg = build_jetton_transfer_msg(
            query_id,
            JETTON_MIN_TRANSFER_FEE + general_state::total_tons_collected + this::operational_needs,
            config::const::fut_jet_dex_amount + config::const::fut_jet_platform_amount,
            tools::const::fut_jet_wallet_address,
            this::chief,
            config::const::min_ton_for_sale_success,
            begin_cell().store_coins(config::const::fut_jet_dex_amount).store_coins(config::const::fut_jet_platform_amount)
        );
        cell claim_admin_msg = begin_cell()
            .store_msg_flags_and_address_none(NON_BOUNCEABLE)
            .store_slice(tools::const::fut_jet_master_address)
            .store_coins(
                get_forward_fee(MY_WORKCHAIN, CLAIM_ADMIN_MSG_BITS, CLAIM_ADMIN_MSG_CELLS)
                + get_compute_fee(MY_WORKCHAIN, CLAIM_ADMIN_GAS_CONSUMPTION)
            )
            .store_prefix_only_body()
            .store_op(op::claim_admin)
            .end_cell();
        send_raw_message(claim_admin_msg, SEND_MODE_REGULAR | SEND_MODE_BOUNCE_ON_ACTION_FAIL);
        send_raw_message(transfer_msg, SEND_MODE_REGULAR | SEND_MODE_BOUNCE_ON_ACTION_FAIL);
    }
}