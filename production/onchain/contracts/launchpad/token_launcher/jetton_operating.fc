#include "../../stdlib.fc";
#include "../op-codes.fc";
#include "../utils.fc";
#include "../gas.fc";

#include "tl_context.fc";
#include "trades_handler.fc";

const int MINT_QUERY_ID = 27082006;

() deploy_launch_jetton() inline {
    (cell jetton_master_stateinit, slice jetton_master_address) = calculate_jetton_master_data();

    ;; Internal message for jetton master jetton wallet
    cell master_msg = begin_cell()
        .store_op(op::internal_transfer)
        .store_query_id(MINT_QUERY_ID)
        .store_coins(this::const::fut_jet_total_supply)
        .store_slice(my_address()) ;; from
        .store_slice(my_address()) ;; response_address
        .store_coins(1) ;; Forwarding 1 nanoton to get transfer_notification
        .store_int(0, 1) ;; store one-bit zero to avoint exit code 9 by TVM
        .end_cell();
    cell msg_body = begin_cell()
        .store_op(op::mint)
        .store_query_id(MINT_QUERY_ID)
        .store_slice(my_address())
        .store_coins(JETTON_MIN_TRANSFER_FEE)
        .store_ref(master_msg)
        .end_cell();
    cell msg = begin_cell()
        .store_msg_flags_and_address_none(BOUNCEABLE)
        .store_slice(jetton_master_address)
        .store_coins(JETTON_MIN_TRANSFER_FEE + 111) ;; TODO Should we calculate computational fee for op::mint?
        .store_statinit_ref_and_body_ref(jetton_master_stateinit, msg_body)
        .end_cell();
    send_raw_message(msg, SEND_MODE_BOUNCE_ON_ACTION_FAIL);
}

() route_incoming_transfer(int query_id, int attached_value, int jetton_amount, slice sender_address, slice initiator) impure inline {
    if (jetton_amount == wl_round::const::pass_util_jet_amount) {
        if (~ equal_slices_bits(sender_address, jet_tools::const::util_jet_wal_addr)) {
            ;; It does mean we just got random tokens on equal amount
            return ();
        }
        handle_wl_purchase(query_id, attached_value, sender_address, initiator);
        return ();
    }
    if (jetton_amount == this::const::fut_jet_total_supply) {
        (cell _jetton_master_stateinit, slice jetton_master_address) = calculate_jetton_master_data();
        slice  our_wallet_address = calculate_user_jetton_wallet_address(
            my_address(), jetton_master_address, jet_tools::const::fut_jet_wallet_code
        );
        if (~ equal_slices_bits(sender_address, our_wallet_address)) {
            ;; It does mean we just got random tokens on equal amount
            return ();
        }
        sale_state::const::fut_jet_deployed? = TRUE;
        ;; TODO Then pool creation logic and pool creation gas measurements
    }
    ;; Also check for init util jettons deposit
}