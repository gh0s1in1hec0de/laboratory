#include "../../stdlib.fc";
#include "../../workchain.fc";

#include "../gas.fc";
#include "../utils.fc";
#include "../op-codes.fc";

#include "tl_context.fc";

() handle_owner_buyout(int query_id, int msg_value) inline {
    throw_unless(error::wrong_time, now() < creator_round::const::end_time);
    int val_left = check_amount_is_enough_for_creator_buyout(msg_value);
    (int jettons_amount, int remainder) = divmod(val_left, creator_round::const::fut_jet_price);

    if (jettons_amount > 0) {
        throw_if(error::balance_overlimit, creator_round::creator_fut_jet_balance + jettons_amount > creator_round::const::fut_jet_limit);
        creator_round::creator_fut_jet_balance += jettons_amount;
        this::fut_jet_cur_balance -= jettons_amount;
    }
    ;; Seems like it will fail almost always, and the remainder will be to small, do we actually need it?
    if (remainder > 0) {
        cell msg = begin_cell()
            .store_msg_flags_and_address_none(NON_BOUNCEABLE)
            .store_slice(this::const::creator_address)
            .store_coins(remainder)
            .store_prefix_only_body()
            .store_op(op::excesses)
            .store_query_id(query_id)
            .end_cell();
        send_raw_message(msg, SEND_MODE_IGNORE_ERRORS);
    }
}

() handle_wl_purchase(int query_id, int attached_value, slice sender_address, slice initiator) inline {
    throw_if(error::wrong_time, now() < creator_round::const::end_time | now() > wl_round::const::end_time);
    int user_value_after_fee = check_amount_is_enough_for_wl_purchase(attached_value);

    if (user_value_after_fee < 0 | wl_round::ton_invested_total + user_value_after_fee <= wl_round::const::ton_limit) {
        cell chargeback_transfer_msg = build_util_jet_transfer_msg(
            query_id,
            wl_round::const::pass_util_jet_amount,
            initiator,
            user_value_after_fee > 0 ? user_value_after_fee : 1
        );
        ;; Taking all the value remains from transfer notification to attach
        send_raw_message(chargeback_transfer_msg, SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE);
        return ();
    }
    ;; Send back all the jettons except burn amount
    ;; If bounced - tokens stays on our balance
    cell return_transfer_msg = build_util_jet_transfer_msg(query_id, wl_round::const::pass_util_jet_amount - wl_round::const::burn_util_jet_amount, initiator, 0);
    send_raw_message(return_transfer_msg, 0);

    ;; We attach value only for routong messages
    int value = get_wl_purchase_gas_consumption() - get_compute_fee(MY_WORKCHAIN, WL_PURCHASE_GAS_CONSUMPTION);
    cell msg = build_balance_update_message(
        query_id,
        value,
        sender_address,
        BALANCE_UPD_DEPOSIT_WL,
        user_value_after_fee,
        0
    );

    send_raw_message(msg, SEND_MODE_BOUNCE_ON_ACTION_FAIL);
    wl_round::ton_invested_total += user_value_after_fee;
    {-
       As out WL phase is fairlaunch - we have static amount of jettons to distribute
       and dynamic value of TON, that can be invested in this round (due to our guarantees to WL investors).
       So, we need to start public sale price from last WL price, than we need to be aware about
       WL round stats changes every time. Then synthetic reserves will continue to change in public round and
       this is the reason, why we don't use `ton_invested_total` for that purposes.
    -}
    public_round::synthetic_ton_reserve += user_value_after_fee;
}

() handle_public_purchase(int query_id, int attached_value, slice sender_address) {
    throw_if(error::wrong_time, now() < wl_round::const::end_time | now() >= public_round::const::end_time);
    ;; `user_value_after_fee` is always more than 0
    int user_value_after_fee = check_amount_is_enough_for_public_purchase(attached_value);
    int res_jettons = get_amount_out(user_value_after_fee, public_round::synthetic_ton_reserve, public_round::synthetic_jet_reserve);

    throw_unless(error::unreachable, res_jettons >= 0);
    throw_unless(error::balance_overlimit, public_round::const::fut_jet_limit >= public_round::fut_jet_sold + res_jettons);
    throw_unless(error::balance_overlimit, this::fut_jet_cur_balance - wl_round::const::fut_jet_limit - res_jettons >= 0);

    ;; Taking care of our synthetic price controllers
    public_round::synthetic_ton_reserve += attached_value;
    public_round::synthetic_jet_reserve -= res_jettons;

    this::fut_jet_cur_balance -= res_jettons;
    public_round::fut_jet_sold += res_jettons;

    ;; Here we attach precise amount of money - as all the remainings gone on ivenstment
    int msg_value = get_balance_update_gas_cost();
    cell msg = build_balance_update_message(
        query_id,
        msg_value,
        sender_address,
        BALANCE_UPD_DEPOSIT_PUB,
        user_value_after_fee,
        res_jettons
    );
    send_raw_message(msg, SEND_MODE_BOUNCE_ON_ACTION_FAIL);
}

() handle_refund_request(int query_id, int attached_value, slice sender_address, int mode, int refund_value) inline {
    throw_if(error::wrong_time, now() < creator_round::const::end_time | now() > public_round::const::end_time);
    throw_unless(error::bad_request, mode == 3 | mode == 4 | mode == 5);
    ;; We don't actually care about leftovers
    int _user_value_after_fee = check_amount_is_enough_for_refund(attached_value);

    cell msg = build_balance_update_message(
        query_id,
        0, ;; Should be rewritten by message sending mode
        sender_address,
        mode,
        refund_value,
        0
    );
    send_raw_message(msg, SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE | SEND_MODE_BOUNCE_ON_ACTION_FAIL);
}

() handle_refund_confirmation(int query_id, int attached_value, slice sender_address, int ton_to_refund, int jettons_to_charge_back, slice recipient) inline {
    slice (_user_vault_stateinit, original_user_vault_address) = calculate_user_vault_data(recipient);
    ;; Verify, that the sender is valid user's vault
    throw_unless(error::unauthorized_access, equal_slices_bits(sender_address, original_user_vault_address));

    ;; Return jettons, owned by users
    this::fut_jet_cur_balance += jettons_to_charge_back;

    cell simple_transfer_message = begin_cell()
        .store_msg_flags_and_address_none(BOUNCEABLE)
        .store_slice(recipient)
        .store_coins(ton_to_refund)
        .store_prefix_only_body()
        .store_op(0)
        .store_query_id(query_id)
        .end_cell();
    send_raw_message(simple_transfer_message, SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE | SEND_MODE_BOUNCE_ON_ACTION_FAIL);
}

() handle_wl_callback(int query_id, int _attached_value, slice sender_address, int should_burn?, int initiator) inline {
    slice (_user_vault_stateinit, original_user_vault_address) = calculate_user_vault_data(initiator);
    ;; Verify, that the sender is valid user's vault
    throw_unless(error::unauthorized_access, equal_slices_bits(sender_address, original_user_vault_address));
    cell msg = should_burn?
    ? build_util_jet_burn_msg(query_id, wl_round::const::burn_util_jet_amount) ;; 1 nanoton to notify user about tokens
    : build_util_jet_transfer_msg(query_id, wl_round::const::burn_util_jet_amount, initiator, 1);

    send_raw_message(msg, SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE);
}

() handle_jetton_claim(int query_id, int attached_value, slice sender_address) {
    (cell user_vault_stateinit, slice user_vault_address) = calculate_user_vault_data(sender_address);

    cell msg_body = begin_cell()
        .store_op(op::uv::claim)
        .store_query_id(query_id)
        .end_cell();
    cell msg = begin_cell()
        .store_msg_flags_and_address_none(BOUNCEABLE)
        .store_slice(user_vault_address)
        .store_coins(msg_value)
        .store_statinit_ref_and_body_ref(user_vault_stateinit, msg_body)
        .end_cell();
}