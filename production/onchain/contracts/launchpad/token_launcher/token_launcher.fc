#include "../../workchain.fc";
#include "../../stdlib.fc";
#include "../op-codes.fc";
#include "../utils.fc";
#include "../gas.fc";

#include "jetton_operating.fc";
#include "trades_handler.fc";
#include "tl_context.fc";

{-
  TODO are we doing this ton-jetton processing the correct way?
  TODO Seems like we should add nine zeroes in couple of places

  TODO initialization and jetton transfer to chief address after Jetton deploy
  TODO to add 1 percent fee

  Questions to Lisa:
  - How we handle rewards per

-}

cell build_content_cell(slice metadata_uri) inline {
    cell content_dict = new_dict();
    content_dict~set_token_snake_metadata_entry("uri"H, metadata_uri);
    content_dict~set_token_snake_metadata_entry("decimals"H, "6");
    return create_token_onchain_metadata(content_dict);
}

;; TODO add following admin options: buys freeze, sells freeeze, util token management
;; TODO should I add our jetton wallet address caching?
() load_data() inline_ref {
    slice ds = get_data().begin_parse();
    this::const::is_initialized? = ds~load_int(1);

    this::const::fut_jet_total_supply = ds~load_coins();
    this::const::min_ton_for_sale_success = ds~load_coins();

    this::fut_jet_cur_balance = ds~load_coins();
    this::reward_util_jets_cur_balance = ds~load_coins();

    this::const::chief_address = ds~load_msg_addr();
    this::const::creator_address = ds~load_msg_addr();

    cell sale_config = ds~load_ref();
    load_sale_config(sale_config);

    cell jet_tools = ds~load_ref();
    slice jet_tools_slice = jet_tools.begin_parse();
    jet_tools::const::util_jet_wal_addr = jet_tools_slice~load_msg_addr();
    jet_tools::const::metadata_uri = jet_tools_slice~load_ref();
    jet_tools::const::fut_jet_minter_code = jet_tools_slice~load_ref();
    jet_tools::const::fut_jet_wallet_code = jet_tools_slice~load_ref();
    jet_tools_slice.end_parse();

    ds.end_parse();
}

() save_data() impure inline_ref {
    ;; Don't forget about cell upper bound - 1023 bits
    ;; Bits: 16 + 267 + 8 + 16 + 32 + 32 + 8 + 8 + 16 + 16 + 16 + 32 + 16*4 + 32
    cell sale_config = begin_cell()
        .store_coins(sale_state::const::fut_jet_deployed_balance)
        .store_slice(sale_state::const::fut_jet_wallet_address)
        .store_uint(creator_round::const::fut_jet_limit, 8)
        .store_coins(creator_round::creator_fut_jet_balance)
        .store_uint(creator_round::const::fut_jet_price, 32)
        .store_int(creator_round::const::end_time, 32)

        .store_uint(wl_round::const::fut_jet_limit, 8)
        .store_uint(wl_round::const::ton_limit, 8)
        .store_coins(wl_round::const::pass_util_jet_amount)
        .store_coins(wl_round::const::burn_util_jet_amount)
        .store_coins(wl_round::ton_invested_total)
        .store_int(wl_round::const::end_time, 32)

        .store_coins(public_round::const::fut_jet_limit)
        .store_coins(public_round::fut_jet_sold)
        .store_coins(public_round::synthetic_jet_reserve)
        .store_coins(public_round::synthetic_ton_reserve)
        .store_int(public_round::const::end_time, 32)
        .store_ref(this::const::user_vault_code)
        .end_cell();

    cell jet_tools = begin_cell()
        .store_slice(jet_tools::const::util_jet_wal_addr)
        .store_ref(jet_tools::const::metadata_uri)
        .store_ref(jet_tools::const::fut_jet_minter_code)
        .store_ref(jet_tools::const::fut_jet_wallet_code)
        .end_cell();

    ;; 1 + 16 * 4 + 16 * 2 + 267 + 267 < 1023
    cell data = begin_cell()
        .store_int(this::const::is_initialized?, 1)
        .store_coins(this::const::fut_jet_total_supply)          ;; VarUinteger16
        .store_coins(this::const::min_ton_for_sale_success)      ;; VarUinteger16
        .store_coins(this::const::fut_jet_dex_amount)            ;; VarUinteger16
        .store_coins(this::const::reward_util_jets_total_amount) ;; VarUinteger16

        .store_coins(this::fut_jet_cur_balance)                  ;; VarUinteger16
        .store_coins(this::reward_util_jets_cur_balance)         ;; VarUinteger16

        .store_slice(this::const::chief_address)                 ;; address(267 bits - common size) todo - prove it
        .store_slice(this::const::creator_address)               ;; address
        .store_ref(sale_config)                                  ;; sale parameters cell
        .store_ref(jet_tools)
        .end_cell();

    set_data(data);
}

() initialize(slice msg_body) impure inline {

    save_data();
}

() on_bounce(int op, int query_id, int attached_value, slice sender_address, slice in_msg_body) impure inline {
    if (op == op::uv::balance_update) {
        int mode = in_msg_body~load_uint(4);
        ;; If it is not deposit
        ifnot (mode == BALANCE_UPD_DEPOSIT_WL | mode == BALANCE_UPD_DEPOSIT_PUB) {
            return ();
        }
        handle_refund_confirmation(
            query_id,
            attached_value,
            sender_address,
            in_msg_body~load_coins(),
            in_msg_body~load_coins(),
            in_msg_body~load_coins(),
            in_msg_body~load_msg_addr()
        );
    }
}

() recv_internal(int contract_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?() | in_msg_body.slice_bits() < 32) {
        return ();
    }
    (int msg_flags, slice sender_address, int attached_value, int fwd_fee_from_in_msg) = extract_full_msg_data(in_msg_full);
    (int op, int query_id) = in_msg_body~load_op_and_query_id();

    load_data(); ;; Now we have our contract data available in globals
    if (msg_flags & 1) {
        on_bounce(op, query_id, attached_value, sender_address, in_msg_body);
        return ();
    }

    if (op == op::tl::init) {
        throw_if(error::already_initialized, this::const::is_initialized?);
        initialize(in_msg_body);
        return ();
    }

    ;; We can't perform any operations before initialization
    throw_unless(error::uninitialized, this::const::is_initialized?);

    if (op == op::tl::creator_buyout) {
        throw_unless(error::unauthorized_access, equal_slices_bits(sender_address, this::const::creator_address));
        raw_reserve(0, RESERVE_WITH_CONTRACT_BALANCE | RESERVE_BOUNCE_ON_ACTION_FAIL);
        handle_owner_buyout(query_id, attached_value);
        save_data();
        return ();
    }

    {-
       Crucial point for our contract, as we determine following operations based on it:
       - WL buy (by detecting WL-pass amount of utility jettons)
       - WL tokens initial deposit (happens, when contract is just created and need its own utility jettons reward amount)
       - Minting all the supply of derived token to our balance (after successfull launch, is needed for distributing)
    -}
    if (op == op::transfer_notification) {
        ;; Verify, that sender is our utility token wallet and no one other
        raw_reserve(0, RESERVE_WITH_CONTRACT_BALANCE); ;; Transfer notification can't be bounced back
        ;; handle_wl_purchase(query_id, in_msg_body~load_coins(), attached_value, sender_address, in_msg_body~load_msg_addr());
        route_incoming_transfer(query_id, attached_value, sender_address, in_msg_body~load_coins(),  in_msg_body~load_msg_addr(), in_msg_body);
        save_data();
        return ();
    }
    if (op == op::tl::wl_callback) {
        raw_reserve(0, RESERVE_WITH_CONTRACT_BALANCE);
        handle_wl_callback(query_id, attached_value, sender_address, in_msg_body~load_bool(), in_msg_body~load_msg_addr());
        ;; Nothing to save as no changes to state were done
        return ();
    }
    if (op == op::tl::public_buy) {
        raw_reserve(0, RESERVE_WITH_CONTRACT_BALANCE | RESERVE_BOUNCE_ON_ACTION_FAIL);
        handle_public_purchase(query_id, attached_value, sender_address);
        save_data();
        return ();
    }
    if (op == op::tl::refund_request) {
        raw_reserve(0, RESERVE_WITH_CONTRACT_BALANCE | RESERVE_BOUNCE_ON_ACTION_FAIL);
        handle_refund_request(query_id, attached_value, sender_address, in_msg_body~load_uint(4), in_msg_body~load_coins());
        return ();
    }
    if (op == op::tl::refund_confirmation) {
        handle_refund_confirmation(query_id, attached_value, sender_address, in_msg_body~load_coins(), in_msg_body~load_coins(), in_msg_body~load_coins(), in_msg_body~load_msg_addr());
        save_data();
        return ();
    }

    if (op == op::tl::deploy_jet) {
        throw_unless(error::unauthorized_access, equal_slices_bits(sender_address, this::const::chief_address));
        accept_message(); ;; TODO Set gas limit after tests
        int launch_success_treshold =
        this::const::min_ton_for_sale_success
        + get_jetton_deploy_gas_cost()
        + calculate_user_vault_min_storage_fee();

        throw_if(error::balance_lack, contract_balance < launch_success_treshold);
        deploy_launch_jetton();
        return ();
    }
    if (op == op::tl::jetton_claim_request) {
        raw_reserve(0, RESERVE_WITH_CONTRACT_BALANCE | RESERVE_BOUNCE_ON_ACTION_FAIL);
        throw_unless(error::wrong_time, now() > public_round::const::end_time);
        ;; For successful claim we need both launch jetton to send and utility jetton to reward
        throw_if(error::tokens_lack, ~ sale_state::const::fut_jet_deployed_balance > 0 | ~ this::reward_util_jets_cur_balance > 0);
        handle_jetton_claim_request(query_id, attached_value, sender_address);
        return ();
    }
    if (op == op::tl::jetton_claim_confirmation) {
        raw_reserve(0, RESERVE_WITH_CONTRACT_BALANCE | RESERVE_BOUNCE_ON_ACTION_FAIL);
        int wl_tons = in_msg_body~load_coins();
        in_msg_body~load_coins(); ;; Skip pub_tons
        int jettons = in_msg_body~load_coins();
        int recipient = in_msg_body~load_msg_addr();
        handle_jetton_claim_confirmation(query_id, attached_value, sender_address, wl_tons, jettons, recipient);
        save_data();
        return ();
    }

    ;; Should I change it somehow?
    if (op == op::excesses) {
        return ();
    }

    throw(error::wrong_op);
}

;; TODO Provide more getters
(int, slice, cell) get_launch_data() method_id {
    load_data();
    throw_unless(error::uninitialized, this::const::is_initialized?);
    return (this::const::fut_jet_total_supply, this::const::creator_address, build_content_cell(jet_tools::const::metadata_uri.begin_parse()));
}
