#include "jetton_operating.fc";
#include "../../workchain.fc";
#include "../../stdlib.fc";
#include "../op-codes.fc";
#include "../utils.fc";

#include "tl_context.fc";
#include "trades_handler.fc";
#include "../gas.fc";

{-
  TODO are we doing this ton-jetton processing the correct way?
  TODO Seems like we should add nine zeroes in couple of places

  Owner round - fixed token price | fixed token limit | remainder goes to public phase
  WL Round    - firlaunch

  sale_data# owner_limit_pct:uint8 owner_balance:Coins owner_token_price:uint32 owner_round_end_time:int32
  wl_tokens_share:unt8 wl_ton_limit_pct:uint8 wl_ton_invested_total:Coins wl_round_end_time:int32
  public_synthetic_reserve_a:Coins public_synthetic_reserve_b:Coins public_round_end_time:int32 = SaleData;

  storage# balance:Coins chief:MsgAddressInt creator: MsgAddressInt
  sale_data: ^SaleData metadata_uri: ^Cell = LaunchStorage;

-}

cell build_content_cell(slice metadata_uri) inline {
    cell content_dict = new_dict();
    content_dict~set_token_snake_metadata_entry("uri"H, metadata_uri);
    content_dict~set_token_snake_metadata_entry("decimals"H, "6");
    return create_token_onchain_metadata(content_dict);
}

;; TODO add following admin options: buys freeze, sells freeeze, util token management
;; TODO should I add our jetton wallet address caching?
() load_data() inline_ref {
    slice ds = get_data().begin_parse();
    this::const::is_initialized? = ds~load_int(1);
    this::const::fut_jet_total_supply = ds~load_coins();
    this::fut_jet_cur_balance = ds~load_coins();
    this::const::min_ton_for_sale_success = ds~load_coins();
    this::const::chief_address = ds~load_msg_addr();
    this::const::creator_address = ds~load_msg_addr();

    cell sale_config = ds~load_ref();
    load_sale_config(sale_config);

    cell jet_tools = ds~load_ref();
    slice jet_tools_slice = jet_tools.begin_parse();
    jet_tools::const::util_jet_wal_addr = jet_tools_slice~load_msg_addr();
    jet_tools::const::metadata_uri = jet_tools_slice~load_ref();
    jet_tools::const::fut_jet_minter_code = jet_tools_slice~load_ref();
    jet_tools::const::fut_jet_wallet_code = jet_tools_slice~load_ref();
    jet_tools_slice.end_parse();

    ds.end_parse();
}

() save_data() impure inline_ref {
    ;; Don't forget about cell upper bound - 1023 bits
    cell sale_config = begin_cell()
        .store_bool(sale_state::const::reward_util_jets_deposited?)
        .store_bool(sale_state::const::fut_jet_deployed?)
        .store_uint(creator_round::const::fut_jet_limit, 8)
        .store_coins(creator_round::creator_fut_jet_balance)
        .store_uint(creator_round::const::fut_jet_price, 32)
        .store_int(creator_round::const::end_time, 32)

        .store_uint(wl_round::const::fut_jet_limit, 8)
        .store_uint(wl_round::const::ton_limit, 8)
        .store_coins(wl_round::const::pass_util_jet_amount)
        .store_coins(wl_round::const::burn_util_jet_amount)
        .store_coins(wl_round::ton_invested_total)
        .store_int(wl_round::const::end_time, 32)

        .store_coins(public_round::const::fut_jet_limit)
        .store_coins(public_round::fut_jet_sold)
        .store_coins(public_round::synthetic_jet_reserve)
        .store_coins(public_round::synthetic_ton_reserve)
        .store_int(public_round::const::end_time, 32)
        .store_ref(this::const::user_vault_code)
        .end_cell();

    cell jet_tools = begin_cell()
        .store_slice(jet_tools::const::util_jet_wal_addr)
        .store_ref(jet_tools::const::metadata_uri)
        .store_ref(jet_tools::const::fut_jet_minter_code)
        .store_ref(jet_tools::const::fut_jet_wallet_code)
        .end_cell();

    ;; 1 + 16 + 16 + 267 + 267 + 267 < 1023
    cell data = begin_cell()
        .store_int(this::const::is_initialized?, 1)
        .store_coins(this::const::fut_jet_total_supply)         ;; VarUinteger16
        .store_coins(this::fut_jet_cur_balance)                 ;; VarUinteger16
        .store_coins(this::const::min_ton_for_sale_success)     ;; VarUinteger16
        .store_slice(this::const::chief_address)                ;; address(267 bits - common size) todo - prove it
        .store_slice(this::const::creator_address)              ;; address
        .store_ref(sale_config)                                 ;; sale parameters cell
        .store_ref(jet_tools)
        .end_cell();

    set_data(data);
}

() initialize(slice msg_body) impure inline {
    ;; TODO early version, now does not work propoerly, rewrite at the end
    int total_supply = msg_body~load_coins();
    this::const::fut_jet_total_supply = total_supply;
    this::fut_jet_cur_balance = total_supply;

    this::const::chief_address = msg_body~load_msg_addr();
    this::const::creator_address = msg_body~load_msg_addr();

    load_sale_config(msg_body~load_ref());
    jet_tools::const::metadata_uri = msg_body~load_ref();

    save_data();
}

() on_bounce(int op, int query_id, int attached_value, slice sender_address, slice in_msg_body) impure inline {
    if (op == op::uv::balance_update) {
        int mode = in_msg_body~load_uint(4);
        ;; If it is not deposit
        ifnot (mode == BALANCE_UPD_DEPOSIT_WL | mode == BALANCE_UPD_DEPOSIT_PUB) {
            return ();
        }
        int tons_to_refund = in_msg_body~load_coins() + in_msg_body~load_coins();
        handle_refund_confirmation(query_id, attached_value, sender_address, tons_to_refund, in_msg_body~load_coins(), in_msg_body~load_msg_addr());
    }
}

() recv_internal(int contract_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?() | in_msg_body.slice_bits() < 32) {
        return ();
    }
    (int msg_flags, slice sender_address, int attached_value, int fwd_fee_from_in_msg) = extract_full_msg_data(in_msg_full);
    (int op, int query_id) = in_msg_body~load_op_and_query_id();

    load_data(); ;; Now we have our contract data available in globals
    if (msg_flags & 1) {
        on_bounce(op, query_id, attached_value, sender_address, in_msg_body);
        return ();
    }

    if (op == op::tl::init) {
        throw_if(error::already_initialized, this::const::is_initialized?);
        initialize(in_msg_body);
        return ();
    }

    ;; We can't perform any operations before initialization
    throw_unless(error::uninitialized, this::const::is_initialized?);

    if (op == op::tl::creator_buyout) {
        throw_unless(error::unauthorized_access, equal_slices_bits(sender_address, this::const::creator_address));
        raw_reserve(0, RESERVE_WITH_CONTRACT_BALANCE | RESERVE_BOUNCE_ON_ACTION_FAIL);
        handle_owner_buyout(query_id, attached_value);
        save_data();
        return ();
    }

    {-
       Crucial point for our contract, as we determine following operations based on it:
       - WL buy (by detecting WL-pass amount of utility jettons)
       - WL tokens initial deposit (happens, when contract is just created and need its own utility jettons reward amount)
       - Minting all the supply of derived token to our balance (after successfull launch, is needed for distributing)
    -}
    if (op == op::transfer_notification) {
        ;; Verify, that sender is our utility token wallet and no one other
        raw_reserve(0, RESERVE_WITH_CONTRACT_BALANCE); ;; Transfer notification can't be bounced back
        ;; handle_wl_purchase(query_id, in_msg_body~load_coins(), attached_value, sender_address, in_msg_body~load_msg_addr());
        route_incoming_transfer(query_id, attached_value, in_msg_body~load_coins(), sender_address, in_msg_body~load_msg_addr());
        save_data();
        return ();
    }
    if (op == op::tl::wl_callback) {
        raw_reserve(0, RESERVE_WITH_CONTRACT_BALANCE);
        handle_wl_callback(query_id, attached_value, sender_address, in_msg_body~load_bool(), in_msg_body~load_msg_addr());
        ;; Nothing to save as no changes to state were done
        return ();
    }
    if (op == op::tl::public_buy) {
        raw_reserve(0, RESERVE_WITH_CONTRACT_BALANCE | RESERVE_BOUNCE_ON_ACTION_FAIL);
        handle_public_purchase(query_id, attached_value, sender_address);
        save_data();
        return ();
    }
    if (op == op::tl::refund_request) {
        raw_reserve(0, RESERVE_WITH_CONTRACT_BALANCE | RESERVE_BOUNCE_ON_ACTION_FAIL);
        handle_refund_request(query_id, attached_value, sender_address, in_msg_body~load_uint(4), in_msg_body~load_coins());
        return ();
    }
    if (op == op::tl::refund_confirmation) {
        int tons_to_refund = in_msg_body~load_coins() + in_msg_body~load_coins();
        handle_refund_confirmation(query_id, attached_value, sender_address, tons_to_refund, in_msg_body~load_coins(), in_msg_body~load_msg_addr());
        save_data();
        return ();
    }

    if (op == op::tl::deploy_jet) {
        throw_unless(error::unauthorized_access, equal_slices_bits(sender_address, this::const::chief_address));
        accept_message(); ;; TODO Set gas limit then
        int launch_success_treshold =
        this::const::min_ton_for_sale_success
        + get_jetton_deploy_gas_cost()
        + calculate_user_vault_min_storage_fee();

        throw_if(error::balance_lack, contract_balance < launch_success_treshold);
        deploy_launch_jetton();
        return ();
    }
    if (op == op::tl::jetton_claim_request) {
        raw_reserve(0, RESERVE_WITH_CONTRACT_BALANCE | RESERVE_BOUNCE_ON_ACTION_FAIL);
        throw_unless(error::wrong_time, now() > public_round::const::end_time);
        throw_unless(error::tokens_lack, sale_state::const::fut_jet_deployed?);
        handle_jetton_claim(query_id, attached_value, sender_address);
        return ();
    }

    ;; Should I change it somehow?
    if (op == op::excesses) {
        return ();
    }

    throw(error::wrong_op);
}

;; TODO Provide more getters
(int, slice, cell) get_launch_data() method_id {
    load_data();
    throw_unless(error::uninitialized, this::const::is_initialized?);
    return (this::const::fut_jet_total_supply, this::const::creator_address, build_content_cell(jet_tools::const::metadata_uri.begin_parse()));
}
