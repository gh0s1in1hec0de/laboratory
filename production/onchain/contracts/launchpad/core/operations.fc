#include "../../stdlib.fc";
#include "../utils.fc";
#include "../gas.fc";

#include "core_context.fc";

() handle_incoming_transfer(int _query_id, int _attached_value, int sender_address,  int jetton_amount, slice _initiator, slice _maybe_payload) {
    slice our_util_jet_wallet_address = calculate_user_jetton_wallet_address(my_address(), this::util_jetton_master_address, code::jetton_wallet);
    if (~ equal_slices_bits(sender_address, our_util_jet_wallet_address)) {
        return ();
    }
    this::util_jet_cur_balance += jetton_amount;
}

() create_launch(int query_id, int attached_value, int sender_address, int total_supply, cell metadata) {
    int start_time = now() + 10; ;; 10 sex gap for transaction processing
    int creator_buyback_jet_limit = muldiv(launch_conf::jet_creator_limit_pct, total_supply, PERCENTAGE_DENOMINATOR);
    int wl_jet_limit = muldiv(launch_conf::jet_wl_limit_pct, total_supply, PERCENTAGE_DENOMINATOR);
    int pub_jet_limit = muldiv(launch_conf::jet_pub_limit_pct, total_supply, PERCENTAGE_DENOMINATOR);
    int dex_jet_share = muldiv(launch_conf::jet_dex_share_pct, total_supply, PERCENTAGE_DENOMINATOR);

    ;; Computatuion bias more than 1%, is it so unreachable btw?
    throw_unless(error::unreachable, creator_buyback_jet_limit + wl_jet_limit + pub_jet_limit + dex_jet_share < muldiv(total_supply, 99, 100));

    cell sale_config = begin_cell()
        .store_coins(0)
        ;; Will be replaced in initialzie() as we can't calculate wallet addresses before calculating its owner address
        .store_address_none()
        .store_coins(creator_buyback_jet_limit)
        .store_coins(0)
        .store_coins(creator_jet_price) ;; TODO
        .store_int(start_time + launch_conf::creator_round_duration_ms, 32)

        .store_coins(wl_jet_limit)
        .store_coins(launch_conf::ton_limit_for_wl_round)
        .store_coins(launch_conf::util_jet_wl_pass_amount)
        .store_coins(launch_conf::util_jet_burn_per_wl_pass_amount)
        .store_coins(0)
        .store_int(start_time + launch_conf::creator_round_duration_ms + launch_conf::wl_round_duration_ms, 32)

        .store_coins(pub_jet_limit)
        .store_coins(0)
    ;; Synthetic reservs aims to start public sale from last WL price
        .store_coins(wl_jet_limit)
        .store_coins(0)
        .store_int(
            start_time
            + launch_conf::creator_round_duration_ms
            + launch_conf::wl_round_duration_ms
            + launch_conf::pub_round_duration_ms,
            32
        )
        .store_ref(code::jetton_launch_user_vault)
        .end_cell();
    cell jet_tools = begin_cell()
        .store_address_none()
        .store_ref(metadata)
        .store_ref(code::derived_jetton_master)
        .store_ref(code::jetton_wallet)
        .end_cell();
    cell data = begin_cell()
        .store_int(0, 1) ;; This flag being set inside initialize() on contract's side
        .store_coins(total_supply)
        .store_coins(launch_conf::min_ton_for_sale_success)
        .store_coins(dex_jet_share)
        .store_coins(0) ;; It will be initialized only in moment of actual enrollment to avoid inconsistent sate

        .store_coins(total_supply)
        .store_coins(0)

        .store_slice(this::chief)
        .store_slice(sender_address)
        .store_ref(sale_config)
        .store_ref(jet_tools)
        .end_cell();
    cell token_launch_stateinit = calculate_contract_state_init(code::jetton_launch, data);
    slice token_launch_address = calculate_contract_address(token_launch_stateinit);

    (cell _fut_jet_master_stateinit, slice fut_jet_master_address) = calculate_fut_jet_master_data(
        code::derived_jetton_master,
        total_supply,
        token_launch_address,
        this::chief,
        code::jetton_wallet,
        metadata
    );
    slice token_launch_fut_jet_wallet_address = calculate_user_jetton_wallet_address(
        token_launch_address, fut_jet_master_address, code::jetton_wallet
    );
    slice util_jet_wallet_address = calculate_user_jetton_wallet_address(
        token_launch_address, this::util_jetton_master_address, code::jetton_wallet
    );

}