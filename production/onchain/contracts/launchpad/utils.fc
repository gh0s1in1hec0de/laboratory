#include "op-codes.fc";
#include "../stdlib.fc";
#include "token_launcher/tl_context.fc";

const MY_WORKCHAIN = BASECHAIN;
const BALANCE_UPD_MODE_SIZE = 4;

const BALANCE_UPD_WL_DEPOSIT = 1;
const BALANCE_UPD_PUB_DEPOSIT = 2;
const BALANCE_UPD_WL_WITHDRAWAL = 3;
const BALANCE_UPD_PUB_WITHDRAWAL = 4;
const BALANCE_UPD_WITHDRAWAL_ALL = 5;

() load_sale_config(cell sale_config) inline_ref {
    slice sale_conf_slice = sale_config.begin_parse();
    sale_state::const::reward_util_jets_deposited? = sale_conf_slice.load_int(1);
    sale_state::const::fut_jet_deployed? = sale_conf_slice.load_int(1);
    sale_state::const::pool_deployed? = sale_conf_slice.load_int(1);

    creator_round::const::fut_jet_limit = sale_conf_slice~load_uint(8)
    creator_round::creator_fut_jet_balance = sale_conf_slice~load_coins();
    creator_round::const::fut_jet_price = sale_conf_slice~load_uint(32);
    creator_round::const::end_time = sale_conf_slice~load_int(32);

    wl_round::const::fut_jet_limit = sale_conf_slice~load_uint(8);
    wl_round::const::ton_limit = sale_conf_slice~load_uint(8);
    wl_round::const::pass_util_jet_amount = sale_conf_slice~load_coins();
    wl_round::const::burn_util_jet_amount = sale_conf_slice~load_coins();
    wl_round::ton_invested_total = sale_conf_slice~load_coins();
    wl_round::const::end_time = sale_conf_slice~load_int(32);

    public_round::const::fut_jet_limit = sale_conf_slice~load_coins();
    public_round::fut_jet_sold = sale_conf_slice~load_coins();
    public_round::synthetic_jet_reserve = sale_conf_slice~load_coins();
    public_round::synthetic_ton_reserve = sale_conf_slice~load_coins();
    public_round::const::end_time = sale_conf_slice~load_int(32);
    this::const::user_vault_code = sale_conf_slice~load_ref();
    sale_conf_slice.end_parse();
}

(int, slice, int, int) extract_full_msg_data(cell in_msg_full) inline_ref {
    slice in_msg_full_slice = in_msg_full.begin_parse();
    int msg_flags = in_msg_full_slice~load_msg_flags();
    slice sender_address = in_msg_full_slice~load_msg_addr();
    in_msg_full_slice~load_msg_addr();                        ;; As recepient is our contarct
    int value = in_msg_full_slice~load_coins();
    in_msg_full_slice~skip_dict();                            ;; skip extracurrency collection
    in_msg_full_slice~load_coins();                           ;; skip ihr_fee
    int fwd_fee = in_msg_full_slice~load_coins();
    return (msg_flags, sender_address, value, fwd_fee);
}

;; TODO Optimize according to DRY later
;;; Now works only with utility token
(cell) build_util_jet_transfer_msg(int query_id, int jetton_amount, slice recipient, int forward_ton_amount) {
    cell msg_body = begin_cell()
        .store_op(op::transfer)
        .store_query_id(query_id)
        .store_coins(jetton_amount)
        .store_slice(recipient) ;; To
        .store_slice(my_address()) ;; Address, that will get excesses after operation
        .store_coins(forward_ton_amount)
        .store_int(0, 1) ;; Either forward payload to avoid TVM exit code 9
        .end_cell();

    ;; Build MessageRelaxed, see TL-B layout in stdlib.fc#L733
    return begin_cell()
        .store_msg_flags_and_address_none(NON_BOUNCEABLE) ;; As we are not able to handle this situation
        .store_slice(jet_tools::const::util_jet_wal_addr)
        .store_coins(0)
        .store_only_body_ref(msg_body)
        .end_cell();
}

;;; Now works only with utility token
(cell) build_util_jet_burn_msg(int query_id, int jetton_amount) {
    cell msg_body = begin_cell()
        .store_op(op::burn)
        .store_query_id(query_id)
        .store_coins(jetton_amount)
        .store_slice(my_address()) ;; Address, that will get excesses after operation
        .end_cell();

    ;; Build MessageRelaxed, see TL-B layout in stdlib.fc#L733
    return begin_cell()
        .store_msg_flags_and_address_none(NON_BOUNCEABLE)
        .store_slice(jet_tools::const::util_jet_wal_addr)
        .store_coins(0)
        .store_only_body_ref(msg_body)
        .end_cell();
}

(int) get_amount_out(int amount_in, int reserve_in, int reserve_out) inline {
    ;; We calculate K according to AMM (Automatic Meow-Meow) formula x*y<=K, where x and y are assets' amounts
    int k = reserve_in * reserve_out; ;; TODO does overflow possible?
    ;; New amount of first asset, that should be in pool
    int new_reserve_in = reserve_in + amount_in;
    ;; We calculate second asset value to have our x*y<=K stay correct,
    ;; `/` division rounds `new_reserve_out` to the lower bound
    int new_reserve_out = k / new_reserve_in;
    int amount_out = reserve_out - new_reserve_out;

    throw_if(error::unreachable, amount_out < 0);
    return amount_out;
}

{-
   Code utils related to smart contracts addresses calculations;
   For this contract it is crucial mechanics as we need to determine
   addresses of user vaults and jetton wallet address correctness
-}

cell calculate_contract_state_init(cell code, cell data) inline_ref {
    {-
    https://github.com/ton-blockchain/ton/blob/8a9ff339927b22b72819c5125428b70c406da631/crypto/block/block.tlb#L144
    _ split_depth:(Maybe (## 5)) special:(Maybe TickTock)
    code:(Maybe ^Cell) data:(Maybe ^Cell)
    library:(Maybe ^Cell) = StateInit;
  -}
    return begin_cell()
        .store_uint(0, 2) ;; 0b00 - No split_depth; No special
        .store_maybe_ref(code)
        .store_maybe_ref(data)
        .store_uint(0, 1) ;; Empty libraries
        .end_cell();
}

slice calculate_contract_address(cell state_init) inline_ref {
    {-
    https://github.com/ton-blockchain/ton/blob/8a9ff339927b22b72819c5125428b70c406da631/crypto/block/block.tlb#L105
    addr_std$10 anycast:(Maybe Anycast) workchain_id:int8 address:bits256  = MsgAddressInt;
    -}
    return begin_cell()
        .store_uint(4, 3) ;; 0b100 = addr_std$10 tag; No anycast
        .store_int(MY_WORKCHAIN, 8)
        .store_uint(cell_hash(state_init), 256)
        .end_cell() ;; can we optimize it?
        .begin_parse();
    ;; Pay attention to amount of bits in address - 267.
    ;; All is needed - to find out concrete cases, where it can differ -
    ;; after that we can be sure in our address size
}

;; TODO finalize at the end
cell pack_user_vault_data(slice owner_address, slice launch_contract_address, int wl_invested, int public_invested, int token_balance) inline {
    return begin_cell()
        .store_slice(owner_address)
        .store_slice(launch_contract_address)
        .store_coins(wl_invested)
        .store_coins(public_invested)
        .store_coins(token_balance)
        .end_cell();
}

(cell, slice) calculate_user_vault_data(slice sender_address) {
    cell user_vault_stateinit = calculate_contract_state_init(
        this::const::user_vault_code,
        pack_user_vault_data(
            sender_address,
            my_address(),
            0,
            0,
            0
        )
    );
    slice user_vault_address = calculate_contract_address(user_vault_stateinit);
    return (user_vault_stateinit, user_vault_address);
}

;; Syntax sugar for jetton wallets and user vaults
cell pack_jetton_wallet_data(int balance, slice owner_address, slice jetton_master_address) inline {
    return begin_cell()
        .store_coins(balance)
        .store_slice(owner_address)
        .store_slice(jetton_master_address)
        .end_cell();
}

slice calculate_user_jetton_wallet_address(slice owner_address, slice jetton_master_address, cell jetton_wallet_code) inline {
    cell jetton_wallet_init_data = pack_jetton_wallet_data(
        0,
        owner_address,
        jetton_master_address
    );
    return calculate_contract_address(calculate_contract_state_init(jetton_wallet_code, jetton_wallet_init_data));
}

cell build_balance_update_message(int query_id, int msg_value, slice user_address, int balance_update_mode, int maybe_tons, int maybe_jettons) inline_ref {
    (cell user_vault_stateinit, slice user_vault_address) = calculate_user_vault_data(user_address);
    cell msg_body = begin_cell()
        .store_op(op::uv::balance_update)
        .store_query_id(query_id)
        .store_uint(balance_update_mode, BALANCE_UPD_MODE_SIZE)
        .store_coins(maybe_tons)
        .store_coins(maybe_jettons)
        .end_cell();
    cell msg = begin_cell()
        .store_msg_flags_and_address_none(BOUNCEABLE)
        .store_slice(user_vault_address)
        .store_coins(msg_value)
        .store_statinit_ref_and_body_ref(user_vault_stateinit, msg_body)
        .end_cell();
    return msg;
}

;; Jetton deployment related tools

cell pack_jetton_master_data() inline {
    return begin_cell()
        .store_coins(this::const::fut_jet_total_supply)
        .store_slice(my_address())
        .store_slice(this::const::chief_address) ;; Emergency case
        .store_ref(jet_tools::const::fut_jet_wallet_code)
        .store_ref(jet_tools::const::metadata_uri)
        .end_cell();
}

(cell, slice) calculate_jetton_master_data() {
    cell jetton_master_stateinit = calculate_contract_state_init(jet_tools::const::fut_jet_wallet_code, pack_jetton_master_data());
    slice jetton_master_address = calculate_contract_address(jetton_master_stateinit);
    return (jetton_master_stateinit, jetton_master_address);
}

