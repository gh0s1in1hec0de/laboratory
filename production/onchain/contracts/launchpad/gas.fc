#include "../stdlib.fc";
#include "../workchain.fc";
#include "op-codes.fc";

const ONE_TON = 1000000000;

const MIN_STORAGE_DURATION = 180 * 24 * 3600; ;; half a year

;; TODO Change almost everything with dummies and real fee computation formulas

;; Precompiled constants
;; All of the contents are result of contract emulation tests

;; Minimal fees
;; Balance update [/sandbox_tests/file#L`line_num`](L`line_num`) `x` TON
const JETTON_MIN_TRANSFER_FEE = 30000000; ;; Actuallly 28627415, but rounded
;; TODO Here should be also all the operation ton fees

;; Storage todo ?
;; Get calculated in a separate test file [/sandbox_tests/StateInit.spec.ts](StateInit.spec.ts)

;; `USER_VAULT_BITS` [/sandbox_tests/file#L`line_num`](L`line_num`)
const USER_VAULT_BITS  = 1;
;; `USER_VAULT_CELLS`: [/sandbox_tests/file#L`line_num`](L`line_num`)
const USER_VAULT_CELLS = 1;

;; `USER_VAULT_INITSTATE_BITS` [/sandbox_tests/file#L`line_num`](L`line_num`)
const USER_VAULT_INITSTATE_BITS  = 1;
;; `USER_VAULT_INITSTATE_CELLS` [/sandbox_tests/file#L`line_num`](L`line_num`)
const USER_VAULT_INITSTATE_CELLS = 1;

;; file#L`line_num` - maunal bits counting
const BALANCE_UPDATE_BITS = 1;
const BALANCE_UPDATE_CELLS = 1;

;; file#L`line_num` - maunal bits counting
const BALANCE_UPDATE_BITS = 1; ;; body = 32+64+124+(3+8+256)+(3+8+256)
const BALANCE_UPDATE_CELLS = 1; ;; body always in ref

;; file#L`line_num` - maunal bits counting
const WL_CALLBACK_BITS = 1; ;; body = 32+64+124+(3+8+256)+(3+8+256)
const WL_CALLBACK_CELLS = 1; ;; body always in ref

;; Gas
;; Gas constants are calculated in the main test suite.
;; First the related transaction is found, and then it's
;; resulting gas consumption is printed to the console.

const RECEIVE_BALANCE_UPDATE_CONSUMPTION = 1;

int calculate_user_vault_min_storage_fee() inline {
    return get_storage_fee(MY_WORKCHAIN, MIN_STORAGE_DURATION, USER_VAULT_BITS, USER_VAULT_CELLS);
}

int forward_user_vault_init_state_overhead() inline {
    return get_simple_forward_fee(MY_WORKCHAIN, USER_VAULT_INITSTATE_BITS, USER_VAULT_INITSTATE_CELLS);
}

(int) get_balance_update_gas_cost() inline_ref {
    return
    get_forward_fee(MY_WORKCHAIN, BALANCE_UPDATE_BITS, BALANCE_UPDATE_CELLS)
    + forward_user_vault_init_state_overhead()
    ;; + get_compute_fee(MY_WORKCHAIN, SEND_BALANCE_UPDATE_CONSUMPTION)
    ;; TODO Does it always consumes the same amount of gas? Seems like all the values are close, so take the upper bound
    + get_compute_fee(MY_WORKCHAIN, RECEIVE_BALANCE_UPDATE_CONSUMPTION)
    + calculate_user_vault_min_storage_fee();
}

;; As we don't have any external calls, we accounting only code execution fees
const CREATOR_BUYOUT_GAS_CONSUMPTION = 1;
(int) check_amount_is_enough_for_creator_buyout(int msg_value) inline {
    int min_value = get_compute_fee(MY_WORKCHAIN, CREATOR_BUYOUT_GAS_CONSUMPTION);
    throw_unless(error::not_enough_gas, msg_value > min_value);
    return msg_value - min_value;
}

;; === WL Purchase ===
;; TODO Measure this 2 operations
const WL_PURCHASE_GAS_CONSUMPTION = 1;
const WL_CALLBACK_GAS_CONSUMPTION = 1;
(int) get_wl_purchase_gas_consumption() inline_ref {
    return get_compute_fee(MY_WORKCHAIN, WL_PURCHASE_GAS_CONSUMPTION)
    + get_balance_update_gas_cost()
    + get_forward_fee(MY_WORKCHAIN, WL_CALLBACK_BITS, WL_CALLBACK_CELLS)
    + get_compute_fee(MY_WORKCHAIN, WL_CALLBACK_GAS_CONSUMPTION);
}

(int) check_amount_is_enough_for_wl_purchase(int msg_value) inline {
    ;; Don't use throw here as we have to return tokens back in case of errors
    return msg_value - get_wl_purchase_gas_consumption();
}

;; === Public Purchase ===
(int) check_amount_is_enough_for_public_purchase(int msg_value) {
    int required_gas = get_balance_update_gas_cost();
    throw_unless(error::not_enough_gas, msg_value > required_gas);
    return msg_value - required_gas;
}

(int) check_amount_is_enough_for_refund(int msg_value) {
    int required_gas = get_balance_update_gas_cost();
    throw_unless(error::not_enough_gas, msg_value > required_gas);
    return msg_value - required_gas;
}

(int) check_amount_is_enough_for_jetton_deploy(int msg_value) {
    {-
       This fee consists of 4 actions:
       - Sending mint request (there is all the validations on the minter's side,
         so, we can include its cost just by including `JETTON_MIN_TRANSFER_FEE`)
       - Accepting tokens by receiving transfer_notification from our wallet
       - Creating fucking pool - now it just represented via `DUMMY_POOL_CREATION_FEES`,
         but later it should be split in pool creation message forward fees, compute fees on our's side and pool's side, delivering stateinit or sth
    -}
    int required_gas = JETTON_MIN_TRANSFER_FEE;
    throw_unless(error::not_enough_gas, msg_value > required_gas);
    return msg_value - required_gas;
}

(int) calc_pool_creation_fee() {
    return 1;
}