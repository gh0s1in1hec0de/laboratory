#include "op-codes.fc";
#include "imports/stdlib.fc";
#include "workchain.fc";

{-
  Storage

  TODO here is also should be some explanations to contract's stages mechanics ot sth like that
  TODO Will we do custom suplly or not?

  Will be extended
  storage#_ balance:Coins chief:MsgAddressInt creator: MsgAddressInt metadata_uri: ^Cell = Storage;
-}

cell build_content_cell(slice metadata_uri) inline {
    cell content_dict = new_dict();
    content_dict~set_token_snake_metadata_entry("uri"H, metadata_uri);
    content_dict~set_token_snake_metadata_entry("decimals"H, "6");
    return create_token_onchain_metadata(content_dict);
}

(int, slice, slice, cell) load_data() inline {
    slice ds = get_data().begin_parse();
    var data = (
        ds~load_coins(),    ;; balance, VarUinteger16
        ds~load_msg_addr(), ;; 295 bits ?
        ds~load_msg_addr()  ;; x2
        ds~load_ref()       ;; x2
    );
    ds.end_parse();
    return data;
}

() save_data(int balance, slice chief, slice creator, cell metadata_uri) impure inline {
    ;; Don't forget about cell upper bound - 1023 bits
    set_data(
        begin_cell()
            .store_coins(balance)
            .store_slice(chief)
            .store_slice(creator)
            .store_ref(metadata_uri)
        .end_cell()
    );
}

() initialize(slice msg_body) {

}

() on_bounce(slice in_msg_body) impure inline {
    ;; Gonna be filled in later
}

() recv_internal(int contract_balance, int attached_value, cell msg_full, slice msg_body) impure {
    if (msg_body.slice_empty?() | msg_body.slice_bits() < 32) {
        ;; TODO is `msg_body.slice_bits() < 32` really necessary?
        ;; Logic for simple transfers
    }
    slice in_msg_full_slice = msg_full.begin_parse();
    int msg_flags = in_msg_full_slice~load_msg_flags();

    if (msg_flags & 1) {
        ;; is bounced
        on_bounce(msg_body);
        return ();
    }

    slice sender_address = in_msg_full_slice~load_msg_addr();

    ;; Purified forward fee of incoming message
    ;; int fwd_fee_from_in_msg = in_msg_full_slice~retrieve_fwd_fee();
    ;; int fwd_fee = get_original_fwd_fee(MY_WORKCHAIN, fwd_fee_from_in_msg);

    int op = msg_body~load_op();
    if (op == op::transfer_notification) { }
    if (op == op::excesses) { {- ??? -} }

    throw(error::wrong_op);
}