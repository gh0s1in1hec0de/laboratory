#include "op-codes.fc";
#include "imports/stdlib.fc";
#include "token_launcher/tl_context.fc";

const MY_WORKCHAIN = BASECHAIN;

() load_sale_config(cell sale_config) inline_ref {
    slice sale_conf_slice = sale_config.begin_parse();
    sale_config::creator_limit_pct = sale_conf_slice~load_uint(8)
    sale_config::creator_balance = sale_conf_slice~load_coins();
    sale_config::creator_token_price = sale_conf_slice~load_uint(32);
    sale_config::creator_round_end_time = sale_conf_slice~load_int(32);

    sale_config::wl_tokens_share = sale_conf_slice~load_uint(8);
    sale_config::wl_ton_limit_pct = sale_conf_slice~load_uint(8);
    sale_config::wl_ton_invested_total = sale_conf_slice~load_coins();
    sale_config::wl_round_end_time = sale_conf_slice~load_int(32);

    sale_config::public_synthetic_reserve_a = sale_conf_slice~load_coins();
    sale_config::public_synthetic_reserve_b = sale_conf_slice~load_coins();
    sale_config::public_round_end_time = sale_conf_slice~load_int(32);
    sale_conf_slice.end_parse();
}

(int, slice, int, int) extract_full_msg_data(cell in_msg_full) inline_ref {
    slice in_msg_full_slice = in_msg_full.begin_parse();
    int msg_flags = in_msg_full_slice~load_msg_flags();
    slice sender_address = in_msg_full_slice~load_msg_addr();
    in_msg_full_slice~load_msg_addr();
    int value = in_msg_full_slice~load_coins();
    in_msg_full_slice~skip_dict();                            ;; skip extracurrency collection
    in_msg_full_slice~load_coins();                           ;; skip ihr_fee
    int fwd_fee = in_msg_full_slice~load_coins();
    return (msg_flags, sender_address, value, fwd_fee);
}

(int) get_amount_out(int amount_in, int reserve_in, int reserve_out) inline {
    ;; we calculate K according to AMM (Automatic Meow-Meow) formula x*y<=K, where x and y are assets' amounts
    int k = reserve_in * reserve_out; ;; TODO does overflow possible?
    ;; new amount of first asset, that should be in pool
    int new_reserve_in = reserve_in + amount_in;
    ;; we calculate second asset value to have our x*y<=K stay correct,
    ;; `/` division rounds `new_reserve_out` to the lower bound
    int new_reserve_out = k / new_reserve_in;
    int amount_out = reserve_out - new_reserve_out;

    throw_if(error::unreachable, amount_out < 0);
    return amount_out;
}

{-
   code utils related to smart contracts addresses calculations;
   for this contract it is crucial mechanics as we need to determine
   addresses of user vaults and jetton wallet address correctness
-}

slice calculate_contract_address(cell state_init) inline_ref {
    {-
    https://github.com/ton-blockchain/ton/blob/8a9ff339927b22b72819c5125428b70c406da631/crypto/block/block.tlb#L105
    addr_std$10 anycast:(Maybe Anycast) workchain_id:int8 address:bits256  = MsgAddressInt;
    -}
    return begin_cell()
        .store_uint(4, 3) ;; 0b100 = addr_std$10 tag; No anycast
        .store_int(MY_WORKCHAIN, 8)
        .store_uint(cell_hash(state_init), 256)
        .end_cell() ;; can we optimize it?
        .begin_parse();
    ;; pay attention to amount of bits in address - 267.
    ;; all is needed - to find out concrete cases, where it can differ.
    ;; after that we can be sure in our address size
}

{-
    jetton wallet address calculatiuon
-}
const int STATUS_SIZE = 4;
cell pack_jetton_wallet_data(int status, int balance, slice owner_address, slice jetton_master_address) inline {
    return begin_cell()
        .store_uint(status, STATUS_SIZE)
        .store_coins(balance)
        .store_slice(owner_address)
        .store_slice(jetton_master_address)
        .end_cell();
}

cell calculate_jetton_wallet_state_init(slice owner_address, slice jetton_master_address, cell jetton_wallet_code) inline_ref {
    {-
    https://github.com/ton-blockchain/ton/blob/8a9ff339927b22b72819c5125428b70c406da631/crypto/block/block.tlb#L144
    _ split_depth:(Maybe (## 5)) special:(Maybe TickTock)
    code:(Maybe ^Cell) data:(Maybe ^Cell)
    library:(Maybe ^Cell) = StateInit;
  -}
    return begin_cell()
        .store_uint(0, 2) ;; 0b00 - No split_depth; No special
        .store_maybe_ref(jetton_wallet_code)
        .store_maybe_ref(
            pack_jetton_wallet_data(
                0, ;; status
                0, ;; balance
                owner_address,
                jetton_master_address
            )
        )
        .store_uint(0, 1) ;; Empty libraries
        .end_cell();
}

slice calculate_user_jetton_wallet_address(slice owner_address, slice jetton_master_address, cell jetton_wallet_code) inline {
    return calculate_contract_address(calculate_jetton_wallet_state_init(owner_address, jetton_master_address, jetton_wallet_code));
}


