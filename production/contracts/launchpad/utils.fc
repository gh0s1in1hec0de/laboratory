#include "op-codes.fc";
#include "imports/stdlib.fc";
#include "token_launcher/tl_context.fc";

const MY_WORKCHAIN = BASECHAIN;

const BALANCE_UPD_MODE_SIZE = 4;
const BALANCE_UPD_WL_DEPOSIT = 1;
const BALANCE_UPD_PUB_DEPOSIT = 2;
const BALANCE_UPD_WL_WITHDRAWAL = 3;
const BALANCE_UPD_WL_WITHDRAWAL = 4;
const BALANCE_UPD_WITHDRAWAL_ALL = 5;

() load_sale_config(cell sale_config) inline_ref {
    slice sale_conf_slice = sale_config.begin_parse();
    sale_config::creator_limit_pct = sale_conf_slice~load_uint(8)
    sale_config::creator_balance = sale_conf_slice~load_coins();
    sale_config::creator_token_price = sale_conf_slice~load_uint(32);
    sale_config::creator_round_end_time = sale_conf_slice~load_int(32);

    sale_config::wl_tokens_share = sale_conf_slice~load_uint(8);
    sale_config::wl_ton_limit_pct = sale_conf_slice~load_uint(8);
    sale_config::wl_ton_invested_total = sale_conf_slice~load_coins();
    sale_config::wl_round_end_time = sale_conf_slice~load_int(32);

    sale_config::public_synthetic_reserve_a = sale_conf_slice~load_coins();
    sale_config::public_synthetic_reserve_b = sale_conf_slice~load_coins();
    sale_config::public_round_end_time = sale_conf_slice~load_int(32);
    sale_conf_slice.end_parse();
}

(int, slice, int, int) extract_full_msg_data(cell in_msg_full) inline_ref {
    slice in_msg_full_slice = in_msg_full.begin_parse();
    int msg_flags = in_msg_full_slice~load_msg_flags();
    slice sender_address = in_msg_full_slice~load_msg_addr();
    in_msg_full_slice~load_msg_addr();
    int value = in_msg_full_slice~load_coins();
    in_msg_full_slice~skip_dict();                            ;; skip extracurrency collection
    in_msg_full_slice~load_coins();                           ;; skip ihr_fee
    int fwd_fee = in_msg_full_slice~load_coins();
    return (msg_flags, sender_address, value, fwd_fee);
}

;; TODO end up building this util later due to `either_forward_payload`
(cell) build_jetton_transfer_msg(int query_id, int jetton_amount, slice recepient, int forward_ton_amount) {
    cell msg_body = begin_cell()
        .store_op(op::transfer)
        .store_query_id(query_id)
        .store_coins(jetton_amount)
        .store_slice(recepient) ;; To
        .store_slice(my_address()) ;; Address, that will get excesses after operation
        .store_coins(forward_ton_amount)
    ;; .store_slice(either_forward_payload) TODO how to avoid saving it at all? Like that?
        .end_cell();

    ;; Build MessageRelaxed, see TL-B layout in stdlib.fc#L733
    cell msg = begin_cell()
        .store_msg_flags_and_address_none(NON_BOUNCEABLE) ;; As this code itself  is fallback - we don't care about that
        .store_slice(this::util_jetton_wal_addr)
        .store_coins(0)
        .store_statinit_ref_and_body_ref(this::util_jetton_wal_stateinit, msg_body)
        .end_cell();
}

(int) get_amount_out(int amount_in, int reserve_in, int reserve_out) inline {
    ;; We calculate K according to AMM (Automatic Meow-Meow) formula x*y<=K, where x and y are assets' amounts
    int k = reserve_in * reserve_out; ;; TODO does overflow possible?
    ;; New amount of first asset, that should be in pool
    int new_reserve_in = reserve_in + amount_in;
    ;; We calculate second asset value to have our x*y<=K stay correct,
    ;; `/` division rounds `new_reserve_out` to the lower bound
    int new_reserve_out = k / new_reserve_in;
    int amount_out = reserve_out - new_reserve_out;

    throw_if(error::unreachable, amount_out < 0);
    return amount_out;
}

{-
   Code utils related to smart contracts addresses calculations;
   For this contract it is crucial mechanics as we need to determine
   addresses of user vaults and jetton wallet address correctness
-}

cell calculate_contract_state_init(cell code, cell data) inline_ref {
    {-
    https://github.com/ton-blockchain/ton/blob/8a9ff339927b22b72819c5125428b70c406da631/crypto/block/block.tlb#L144
    _ split_depth:(Maybe (## 5)) special:(Maybe TickTock)
    code:(Maybe ^Cell) data:(Maybe ^Cell)
    library:(Maybe ^Cell) = StateInit;
  -}
    return begin_cell()
        .store_uint(0, 2) ;; 0b00 - No split_depth; No special
        .store_maybe_ref(code)
        .store_maybe_ref(data)
        .store_uint(0, 1) ;; Empty libraries
        .end_cell();
}

slice calculate_contract_address(cell state_init) inline_ref {
    {-
    https://github.com/ton-blockchain/ton/blob/8a9ff339927b22b72819c5125428b70c406da631/crypto/block/block.tlb#L105
    addr_std$10 anycast:(Maybe Anycast) workchain_id:int8 address:bits256  = MsgAddressInt;
    -}
    return begin_cell()
        .store_uint(4, 3) ;; 0b100 = addr_std$10 tag; No anycast
        .store_int(MY_WORKCHAIN, 8)
        .store_uint(cell_hash(state_init), 256)
        .end_cell() ;; can we optimize it?
        .begin_parse();
    ;; Pay attention to amount of bits in address - 267.
    ;; All is needed - to find out concrete cases, where it can differ -
    ;; after that we can be sure in our address size
}

cell pack_user_vault_data(slice owner_address, slice launch_contract_address, int wl_jet_pass_burnt, int wl_invested, int public_invested, int token_balance) inline {
    return begin_cell()
        .store_slice(owner_address)
        .store_slice(launch_contract_address)
        .store_bool(wl_jet_pass_burnt)
        .store_coins(wl_invested)
        .store_coins(public_invested)
        .store_coins(token_balance)
        .end_cell();
}

;; Syntax sugar for jetton wallets and user vaults

const int STATUS_SIZE = 4;
cell pack_jetton_wallet_data(int status, int balance, slice owner_address, slice jetton_master_address) inline {
    return begin_cell()
        .store_uint(status, STATUS_SIZE)
        .store_coins(balance)
        .store_slice(owner_address)
        .store_slice(jetton_master_address)
        .end_cell();
}

slice calculate_user_jetton_wallet_address(slice owner_address, slice jetton_master_address, cell jetton_wallet_code) inline {
    cell jetton_wallet_init_data = pack_jetton_wallet_data(
        0, ;; status
        0, ;; balance
        owner_address,
        jetton_master_address
    );
    return calculate_contract_address(calculate_contract_state_init(jetton_wallet_code, jetton_wallet_init_data));
}

