#include "imports/stdlib.fc";
#include "token_launcher/tl_context.fc";

const MY_WORKCHAIN = BASECHAIN;

(int, int, int, int, int) load_sale_config(cell sale_config) inline_ref {
    slice sale_conf_slice = sale_config.begin_parse();
    sale_config::creator_limit_pct = sale_conf_slice~load_uint(8);
    sale_config::creator_balance = sale_conf_slice~load_coins();
    sale_config::creator_token_price = sale_conf_slice~load_uint(32);
    sale_config::owner_round_end_time = sale_conf_slice~load_int(32);
    sale_config::wl_round_end_time = sale_conf_slice~load_int(32);
    sale_config::hamster_round_end_time = sale_conf_slice~load_int(32);
}

(int, slice, int, int) extract_full_msg_data(cell in_msg_full) inline_ref {
    slice in_msg_full_slice = in_msg_full.begin_parse();
    int msg_flags = in_msg_full_slice~load_msg_flags();
    slice sender_address = in_msg_full_slice~load_msg_addr();
    in_msg_full_slice~load_msg_addr();
    int value = in_msg_full_slice~load_coins();
    in_msg_full_slice~skip_dict(); ;; skip extracurrency collection
    in_msg_full_slice~load_coins(); ;; skip ihr_fee
    int fwd_fee = in_msg_full_slice~load_coins();
    return (msg_flags, sender_address, value, fwd_fee);
}

slice calculate_user_vault_address(cell state_init) inline {
    {-
    https://github.com/ton-blockchain/ton/blob/8a9ff339927b22b72819c5125428b70c406da631/crypto/block/block.tlb#L105
    addr_std$10 anycast:(Maybe Anycast) workchain_id:int8 address:bits256  = MsgAddressInt;
    -}
    return begin_cell()
        .store_uint(4, 3) ;; 0b100 = addr_std$10 tag; No anycast
        .store_int(MY_WORKCHAIN, 8)
        .store_uint(cell_hash(state_init), 256)
        .end_cell()
        .begin_parse();
    ;; pay attention to amount of bits in address - 267.
    ;; all is needed - to find out concrete cases, where it can differ.
    ;; after that we can be sure in our address size
}

;; TODO
() get_amount_out(int amount_in, int reserve_in, int reserve_out) inline {
    int base_out = (amount_in * reserve_out) / reserve_in;
}