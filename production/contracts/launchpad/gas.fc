#include "../stdlib.fc";
#include "../workchain.fc.fc";
#include "op-codes.fc";

const ONE_TON = 1000000000;

const MIN_STORAGE_DURATION = 180 * 24 * 3600; ;; half a year

;; TODO Change almost everything with dummies and real fee computation formulas

;; Precompiled constants
;; All of the contents are result of contract emulation tests

;; Minimal fees
;; Balance update [/sandbox_tests/file#L`line_num`](L`line_num`) `x` TON

;; Storage todo ?
;; Get calculated in a separate test file [/sandbox_tests/StateInit.spec.ts](StateInit.spec.ts)

;; `USER_VAULT_BITS` [/sandbox_tests/file#L`line_num`](L`line_num`)
const USER_VAULT_BITS  = 1;
;; `USER_VAULT_CELLS`: [/sandbox_tests/file#L`line_num`](L`line_num`)
const USER_VAULT_CELLS = 1;


;; `USER_VAULT_INITSTATE_BITS` [/sandbox_tests/file#L`line_num`](L`line_num`)
const USER_VAULT_INITSTATE_BITS  = 1;
;; `USER_VAULT_INITSTATE_CELLS` [/sandbox_tests/file#L`line_num`](L`line_num`)
const USER_VAULT_INITSTATE_CELLS = 1;

;; jetton_wallet.fc#L163 - maunal bits counting
const BALANCE_UPDATE_BITS = 1; ;; body = 32+64+124+(3+8+256)+(3+8+256)
const BALANCE_UPDATE_CELLS = 1; ;; body always in ref

;; Gas
;; Gas constants are calculated in the main test suite.
;; First the related transaction is found, and then it's
;; resulting gas consumption is printed to the console.

;; TODO link gas measurement code line
const SEND_BALANCE_UPDATE_CONSUMPTION    = 1;

;; TODO link gas measurement code line
const RECEIVE_BALANCE_UPDATE_CONSUMPTION = 1;

int calculate_jetton_wallet_min_storage_fee() inline {
    return get_storage_fee(MY_WORKCHAIN, MIN_STORAGE_DURATION, USER_VAULT_BITS, USER_VAULT_CELLS);
}

int forward_init_state_overhead() inline {
    return get_simple_forward_fee(MY_WORKCHAIN, USER_VAULT_INITSTATE_BITS, USER_VAULT_INITSTATE_CELLS);
}

;; TODO Warning! Gas counting is dummy now!

;;; Returns difference between attached value and gas spendings
(int) get_balance_update_gas() {
    ;; TODO Count state init for user vault
    return get_forward_fee(MY_WORKCHAIN, BALANCE_UPDATE_BITS, BALANCE_UPDATE_CELLS)
    + get_compute_fee(MY_WORKCHAIN, SEND_BALANCE_UPDATE_CONSUMPTION)
    + get_compute_fee(MY_WORKCHAIN, RECEIVE_BALANCE_UPDATE_CONSUMPTION);
}

(int) check_amount_is_enough_for_creator_buyout(int msg_value) {
    ;; It does not use balance update at all, so it should be changed in general
    int required_gas = get_balance_update_gas();
    throw_unless(error::not_enough_gas, msg_value > required_gas);
    return msg_value - required_gas;
}

(int) check_amount_is_enough_for_wl_purchase(int msg_value) {
    ;; TODO count 2 utility jetton transfers and burn validation message
    int required_gas = get_balance_update_gas();
    ;; Don't use throw here as we shouldn't throw shit in wl buys
    return msg_value - required_gas;
}

(int) check_amount_is_enough_for_public_purchase(int msg_value) {
    int required_gas = get_balance_update_gas();
    throw_unless(error::not_enough_gas, msg_value > required_gas);
    return msg_value - required_gas;
}

(int) check_amount_is_enough_for_refund(int msg_value) {
    int required_gas = get_balance_update_gas();
    throw_unless(error::not_enough_gas, msg_value > required_gas);
    return msg_value - required_gas;
}

