#include "../stdlib.fc";
#include "../workchain.fc";
#include "op-codes.fc";

const ONE_TON = 1000000000;

const MIN_STORAGE_DURATION = 180 * 24 * 3600; ;; half a year

;; TODO Change almost everything with dummies and real fee computation formulas

;; Precompiled constants
;; All of the contents are result of contract emulation tests

;; Minimal fees
;; Balance update [/sandbox_tests/file#L`line_num`](L`line_num`) `x` TON
const JETTON_MIN_TRANSFER_FEE = 30000000; ;; Actuallly 28627415, but rounded

;; Storage todo ?
;; Get calculated in a separate test file [/sandbox_tests/StateInit.spec.ts](StateInit.spec.ts)

;; `USER_VAULT_BITS` [/sandbox_tests/file#L`line_num`](L`line_num`)
const USER_VAULT_BITS  = 1;
;; `USER_VAULT_CELLS`: [/sandbox_tests/file#L`line_num`](L`line_num`)
const USER_VAULT_CELLS = 1;

;; `USER_VAULT_INITSTATE_BITS` [/sandbox_tests/file#L`line_num`](L`line_num`)
const USER_VAULT_INITSTATE_BITS  = 1;
;; `USER_VAULT_INITSTATE_CELLS` [/sandbox_tests/file#L`line_num`](L`line_num`)
const USER_VAULT_INITSTATE_CELLS = 1;

;; jetton_wallet.fc#L163 - maunal bits counting
const BALANCE_UPDATE_BITS = 1; ;; body = 32+64+124+(3+8+256)+(3+8+256)
const BALANCE_UPDATE_CELLS = 1; ;; body always in ref

;; Gas
;; Gas constants are calculated in the main test suite.
;; First the related transaction is found, and then it's
;; resulting gas consumption is printed to the console.

;; TODO link gas measurement code line
const SEND_BALANCE_UPDATE_CONSUMPTION    = 1;

;; TODO link gas measurement code line
const RECEIVE_BALANCE_UPDATE_CONSUMPTION = 1;

int calculate_jetton_wallet_min_storage_fee() inline {
    return get_storage_fee(MY_WORKCHAIN, MIN_STORAGE_DURATION, USER_VAULT_BITS, USER_VAULT_CELLS);
}

int forward_init_state_overhead() inline {
    return get_simple_forward_fee(MY_WORKCHAIN, USER_VAULT_INITSTATE_BITS, USER_VAULT_INITSTATE_CELLS);
}

;; TODO Warning! Gas counting is dummy now!

;;; Returns difference between attached value and gas spendings
(int) get_balance_update_gas() {
    ;; TODO Count state init for user vault
    return get_forward_fee(MY_WORKCHAIN, BALANCE_UPDATE_BITS, BALANCE_UPDATE_CELLS)
    + get_compute_fee(MY_WORKCHAIN, SEND_BALANCE_UPDATE_CONSUMPTION)
    + get_compute_fee(MY_WORKCHAIN, RECEIVE_BALANCE_UPDATE_CONSUMPTION);
}

(int) check_amount_is_enough_for_creator_buyout(int msg_value) {
    ;; It does not use balance update at all, so it should be changed in general
    int required_gas = get_balance_update_gas();
    throw_unless(error::not_enough_gas, msg_value > required_gas);
    return msg_value - required_gas;
}

(int) check_amount_is_enough_for_wl_purchase(int msg_value) {
    ;; TODO count 2 utility jetton transfers and burn validation message
    int required_gas = get_balance_update_gas();
    ;; Don't use throw here as we shouldn't throw shit in wl buys
    return msg_value - required_gas;
}

(int) check_amount_is_enough_for_public_purchase(int msg_value) {
    int required_gas = get_balance_update_gas();
    throw_unless(error::not_enough_gas, msg_value > required_gas);
    return msg_value - required_gas;
}

(int) check_amount_is_enough_for_refund(int msg_value) {
    int required_gas = get_balance_update_gas();
    throw_unless(error::not_enough_gas, msg_value > required_gas);
    return msg_value - required_gas;
}

(int) check_amount_is_enough_for_jetton_deploy(int msg_value) {
    {-
       This fee consists of 4 actions:
       - Sending mint request (there is all the validations on the minter's side,
         so, we can include its cost just by including `JETTON_MIN_TRANSFER_FEE`)
       - Accepting tokens by receiving transfer_notification from our wallet
       - Creating fucking pool - now it just represented via `DUMMY_POOL_CREATION_FEES`,
         but later it should be split in pool creation message forward fees, compute fees on our's side and pool's side, delivering stateinit or sth
    -}
    int required_gas = JETTON_MIN_TRANSFER_FEE;
    throw_unless(error::not_enough_gas, msg_value > required_gas);
    return msg_value - required_gas;
}

(int) calc_pool_creation_fee() {
    return 1;
}