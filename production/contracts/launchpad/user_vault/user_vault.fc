#include "balance_handler.fc";
#include "../../stdlib.fc";
#include "../op-codes.fc";
#include "../../workchain.fc.fc";
#include "../utils.fc";

#include "uv_context.fc";

() load_data() inline_ref {
    slice ds = get_data().begin_parse();
    this::owner_addr = ds~load_msg_addr();
    this::token_launch_addr = ds~load_msg_addr();
    this::wl_ton_balance = ds~load_coins();
    this::public_ton_balance = ds~load_coins();
    this::jetton_balance = ds~load_coins();
    ds.end_parse();
}

() save_data() impure inline_ref {
    set_data(
        begin_cell()
            .store_slice(this::owner_addr)
            .store_slice(this::token_launch_addr)
            .store_coins(this::wl_ton_balance)
            .store_coins(this::public_ton_balance)
            .store_coins(this::jetton_balance)
            .end_cell()
    );
}

() on_bounce(slice in_msg_body) impure inline {
    ;; Here should be bad refunds/claims revertions
}

() recv_internal(int contract_balance, int attached_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?() | in_msg_body.slice_bits() < 32) {
        ;; TODO is `msg_body.slice_bits() < 32` really necessary?
        ;; Logic for simple transfers
    }
    (int msg_flags, slice sender_address, int attached_value, int fwd_fee_from_in_msg) = extract_full_msg_data(in_msg_full);
    (int op, int query_id) = in_msg_body~load_op_and_query_id();

    if (msg_flags & 1) {
        ;; Is bounced
        on_bounce(in_msg_body);
        return ();
    }

    ;; Purified forward fee of incoming message
    ;; int fwd_fee = get_original_fwd_fee(MY_WORKCHAIN, fwd_fee_from_in_msg);
    load_data(); ;; Now we have our contract data available in globals

    if (op == op::uv::balance_update) {
        throw_unless(error::unauthorized_access, equal_slices_bits(sender_address, this::token_launch_addr));
        handle_balance_update(
            query_id,
            in_msg_body~load_uint(4),
            in_msg_body~load_coins(),
            in_msg_body~load_coins()
        );
        return ();
    }

    throw(error::wrong_op);
}

(int, slice, cell, cell) get_user_data() method_id {
    load_data();
    ;; Should return owner, all balance-related data
    return ();
}