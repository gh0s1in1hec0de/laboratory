#include "../gas.fc";
#include "../op-codes.fc";
#include "../imports/stdlib.fc";

#include "tl_context.fc";
#include "../utils.fc";

() handle_owner_buyout(int msg_value) {
    int val_left = check_amount_is_enough_for_owner_buyout(msg_value);
    (int tokens_amount, int remainder) = divmod(val_left, sale_config::creator_token_price);

    if (tokens_amount > 0) {
        int creator_token_limit  = muldiv(sale_config::creator_limit_pct, this::total_supply, 100);
        throw_if(error::balance_overlimit, sale_config::creator_balance + tokens_amount > creator_token_limit);
        sale_config::creator_balance += tokens_amount;
    }
    ;; TODO - if remainder is more than returning excesses message fee - than send excesses to owner
    if (remainder > 0) { }
}

() handle_wl_purchase(int query_id, int jetton_amount, int msg_value, slice sender_address, slice initiator) inline {
    int val_left = check_amount_is_enough_for_wl_purchase(msg_value);
    ;; TODO to add contracint, that we are not out off ton investment limit bounds
    ;; It should work like: if even one of them is true - we'll try to return sender's tokens back
    if (sender_address != this::util_jetton_wal_addr | jetton_amount <= sale_config::wl_pass_min_util_jet_amount | val_left < 0) {
        ;; To figure out - what gonna happen, if we run out of gas? At my opinion we have 2 variants:
        ;; - we still have enough gas to perform the cashback operartion -> code stops at return(), we also have no data to save
        ;; - we just run out of gas and being stopped at random place,so the tokens will be left on this contract's balance,
        ;;   but, at least, we will not face any inconsistent state, or something like that
        cell chargeback_transfer_msg = build_jetton_transfer_msg(query_id, jetton_amount, initiator, val_left > 0 ? val_left : 0); ;; Is it legal? :)

        ;; Taking all the value remains from transfer notification to attach
        send_raw_message(chargeback_transfer_msg, SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE);
        return();
    }

    cell user_vault_stateinit = calculate_contract_state_init(
        this::user_vault_code,
      pack_user_vault_data(
          sender_address,
          my_address(),
          FALSE,
          0,
          0,
          0
      )
    );
    slice user_vault_address = calculate_contract_address(user_vault_stateinit);

    ;; Send back all the jettons except burn amount
    cell return_transfer_msg = build_jetton_transfer_msg(query_id, jetton_amount - sale_config::wl_burn_util_jet_amount, initiator, 0);
    send_raw_message(chargeback_transfer_msg, SEND_MODE_IGNORE_ERRORS);

    ;; Send balance update
    cell msg_body = begin_cell()
        .store_op(op::uv::balance_update)
        .store_query_id(query_id)
        .store_uint(BALANCE_UPD_WL_DEPOSIT, BALANCE_UPD_MODE_SIZE)
        .store_coins(val_left)
        .store_coins(0)
        .end_cell();

    cell msg = begin_cell()
        .store_msg_flags_and_address_none(BOUNCEABLE)
        .store_slice(user_vault_address)
        .store_coins(0) ;; Must be rewritten by message mode
        .store_statinit_ref_and_body_ref(user_vault_stateinit, msg_body)
        .end_cell();

    send_raw_message(msg, SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE | SEND_MODE_BOUNCE_ON_ACTION_FAIL);
    sale_config::wl_ton_invested_total += val_left;
}

() handle_public_purchase(msg_value) {

}