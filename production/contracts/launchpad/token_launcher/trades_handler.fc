#include "../gas.fc";
#include "../utils.fc";
#include "../op-codes.fc";
#include "../../stdlib.fc";

#include "tl_context.fc";

() handle_owner_buyout(int msg_value) inline {
    throw_unless(error::wrong_time, now() < creator_round::const::end_time);
    int val_left = check_amount_is_enough_for_creator_buyout(msg_value);
    (int tokens_amount, int remainder) = divmod(val_left, creator_round::const::fut_jet_price);

    if (tokens_amount > 0) {
        throw_if(error::balance_overlimit, creator_round::creator_fut_jet_balance + tokens_amount > creator_round::const::fut_jet_limit);
        creator_round::creator_fut_jet_balance += tokens_amount;
    }
    ;; TODO - if remainder is more than returning excesses message fee - than send excesses to owner
    if (remainder > 0) { }
}

() handle_wl_purchase(int query_id, int jetton_amount, int attached_value, slice sender_address, slice initiator) inline {
    throw_if(error::wrong_time, now() < creator_round::const::end_time | now() > wl_round::const::end_time);
    int user_value_after_fee = check_amount_is_enough_for_wl_purchase(attached_value);
    ;; TODO to add contracint, that we are not out off ton investment limit bounds
    ;; It should work like: if even one of them is true - we'll try to return sender's tokens back
    if (jetton_amount < wl_round::const::pass_min_util_jet_amount
    | user_value_after_fee < 0 | ~ equal_slices_bits(sender_address, jet_tools::const::util_jet_wal_addr)
    | wl_round::ton_invested_total + user_value_after_fee <= wl_round::const::ton_limit) {
        ;; TODO To figure out - what gonna happen, if we run out of gas? At my opinion we have 2 variants:
        ;; - we still have enough gas to perform the cashback operartion -> code stops at return(), we also have no data to save
        ;; - we just run out of gas and being stopped at random place,so the tokens will be left on this contract's balance,
        ;;   but, at least, we will not face any inconsistent state, or something like that
        cell chargeback_transfer_msg = build_util_jet_transfer_msg(query_id, jetton_amount, initiator, user_value_after_fee > 0 ? user_value_after_fee : 0); ;; Is it legal? :)

        ;; Taking all the value remains from transfer notification to attach
        send_raw_message(chargeback_transfer_msg, SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE);
        return ();
    }
    ;; Send back all the jettons except burn amount
    ;; If bounced - tokens stays on our balance
    cell return_transfer_msg = build_util_jet_transfer_msg(query_id, jetton_amount - wl_round::const::burn_util_jet_amount, initiator, 0);
    send_raw_message(return_transfer_msg, 0);

    {-
      Dummy value here should include:
      - fwd_fee for balance update message
      - computational fee for balance update on vault's side
      - fwd_fee and computational fees for burn confirmation/reject

      Invested TONs stays on this contract!
    -}
    int dummy_value = 1; ;; TODO
    cell msg = build_balance_update_message(
        query_id,
        dummy_value,
        sender_address,
        BALANCE_UPD_WL_DEPOSIT,
        user_value_after_fee,
        0
    );

    send_raw_message(msg, SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE | SEND_MODE_BOUNCE_ON_ACTION_FAIL);
    wl_round::ton_invested_total += user_value_after_fee;
    {-
       As out WL phase is fairlaunch - we have static amount of jettons to distribute
       and dynamic value of TON, that can be invested in this round (due to our guarantees to WL investors).
       So, we need to start public sale price from last WL price, than we need to be aware about
       WL round stats changes every time. Then synthetic reserves will continue to change in public round and
       this is the reason, why we don't use `ton_invested_total` for that purposes.
    -}
    public_round::synthetic_ton_reserve += user_value_after_fee;
}

;; TODO accomplish all the intricate mechanics, they are not complete
() handle_public_purchase(int query_id, int attached_value, slice sender_address) {
    throw_if(error::wrong_time, now() < wl_round::const::end_time | now() > public_round::const::end_time);
    ;; `user_value_after_fee` is always more than 0
    int user_value_after_fee = check_amount_is_enough_for_public_purchase(attached_value);
    int res_jettons = get_amount_out(user_value_after_fee, public_round::synthetic_ton_reserve, public_round::synthetic_jet_reserve);
    throw_if(error::unreachable, res_jettons <= 0);

    public_round::synthetic_ton_reserve += attached_value;
    public_round::synthetic_jet_reserve -= res_jettons;

    ;; TODO Only fee for forwarding and execution balance update
    int dummy_value = 1;
    cell msg = build_balance_update_message(
        query_id,
        dummy_value,
        sender_address,
        BALANCE_UPD_PUB_DEPOSIT,
        user_value_after_fee,
        res_jettons
    );
    send_raw_message(msg, SEND_MODE_BOUNCE_ON_ACTION_FAIL);
}

() handle_refund_request(int query_id, int attached_value, slice sender_address, int mode, int refund_value) inline {
    throw_if(error::wrong_time, now() < creator_round::const::end_time | now() > public_round::const::end_time);
    throw_unless(error::bad_request, mode == 3 | mode == 4 | mode == 5);
    ;; We don't actually care about leftovers
    (int _user_value_after_fee) = check_amount_is_enough_for_refund(attached_value);

    cell msg = build_balance_update_message(
        query_id,
        0, ;; Should be rewritten by message sending mode
        sender_address,
        mode,
        refund_value,
        0
    );
    send_raw_message(msg, SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE | SEND_MODE_BOUNCE_ON_ACTION_FAIL);
}

() handle_refund_confirmation(int query_id, slice sender_address, int ton_to_refund, int jettons_to_charge_back, slice recipient) inline {
    slice (_user_vault_stateinit, original_user_vault_address) = calculate_user_vault_data(recipient);
    ;; Verify, that the sender is valid user's vault
    throw_unless(error::unauthorized_access, equal_slices_bits(sender_address, original_user_vault_address));

    ;; Return jettons, owned by users
    this::fut_jet_cur_balance += jettons_to_charge_back;

    cell simple_transfer_message = begin_cell()
        .store_msg_flags_and_address_none(BOUNCEABLE)
        .store_slice(recipient)
        .store_coins(ton_to_refund)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_op(0) ;; Is it allowed to do like that?
        .store_query_id(query_id)
        .end_cell();
    send_raw_message(simple_transfer_message, SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE);
}

() handle_wl_callback(int query_id, int _attached_value, slice sender_address, int should_burn?, int initiator) inline {
    slice (_user_vault_stateinit, original_user_vault_address) = calculate_user_vault_data(initiator);
    ;; Verify, that the sender is valid user's vault
    throw_unless(error::unauthorized_access, equal_slices_bits(sender_address, original_user_vault_address));
    cell msg = should_burn?
    ? build_util_jet_burn_msg(query_id, wl_round::const::burn_util_jet_amount) ;; 1 nanoton to notify user about tokens
    : build_util_jet_transfer_msg(query_id, wl_round::const::burn_util_jet_amount, initiator, 1);

    send_raw_message(msg, SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE);
}