#include "../gas.fc";
#include "../op-codes.fc";
#include "../imports/stdlib.fc";

#include "tl_context.fc";
#include "../utils.fc";

() handle_owner_buyout(int msg_value) {
    int val_left = check_amount_is_enough_for_owner_buyout(msg_value);
    (int tokens_amount, int remainder) = divmod(val_left, creator_round::const::jet_price);

    if (tokens_amount > 0) {
        throw_if(error::balance_overlimit, creator_round::creator_jet_balance + tokens_amount > creator_round::const::jet_limit);
        creator_round::creator_jet_balance += tokens_amount;
    }
    ;; TODO - if remainder is more than returning excesses message fee - than send excesses to owner
    if (remainder > 0) { }
}

() handle_wl_purchase(int query_id, int jetton_amount, int msg_value, slice sender_address, slice initiator) inline {
    int user_value_after_fee = check_amount_is_enough_for_wl_purchase(msg_value);
    ;; TODO to add contracint, that we are not out off ton investment limit bounds
    ;; It should work like: if even one of them is true - we'll try to return sender's tokens back
    if (jetton_amount < wl_round::const::pass_min_util_jet_amount
       | user_value_after_fee < 0 | sender_address != this::const::util_jetton_wal_addr
       | wl_round::ton_invested_total + user_value_after_fee <= wl_round::const::ton_limit ) {
        ;; To figure out - what gonna happen, if we run out of gas? At my opinion we have 2 variants:
        ;; - we still have enough gas to perform the cashback operartion -> code stops at return(), we also have no data to save
        ;; - we just run out of gas and being stopped at random place,so the tokens will be left on this contract's balance,
        ;;   but, at least, we will not face any inconsistent state, or something like that
        cell chargeback_transfer_msg = build_jetton_transfer_msg(query_id, jetton_amount, initiator, user_value_after_fee > 0 ? user_value_after_fee : 0); ;; Is it legal? :)

        ;; Taking all the value remains from transfer notification to attach
        send_raw_message(chargeback_transfer_msg, SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE);
        return();
    }

    cell user_vault_stateinit = calculate_contract_state_init(
        this::const::user_vault_code,
      pack_user_vault_data(
          sender_address,
          my_address(),
          FALSE,
          0,
          0,
          0
      )
    );
    slice user_vault_address = calculate_contract_address(user_vault_stateinit);

    ;; Send back all the jettons except burn amount
    ;; If bounced - tokens stays on our balance
    cell return_transfer_msg = build_jetton_transfer_msg(query_id, jetton_amount - wl_round::const::burn_util_jet_amount, initiator, 0);
    send_raw_message(return_transfer_msg, 0);

    ;; Send balance update
    cell msg_body = begin_cell()
        .store_op(op::uv::balance_update)
        .store_query_id(query_id)
        .store_uint(BALANCE_UPD_WL_DEPOSIT, BALANCE_UPD_MODE_SIZE)
        .store_coins(user_value_after_fee)
        .store_coins(0)
        .end_cell();

    cell msg = begin_cell()
        .store_msg_flags_and_address_none(BOUNCEABLE)
        .store_slice(user_vault_address)
        .store_coins(0) ;; Must be rewritten by message mode
        .store_statinit_ref_and_body_ref(user_vault_stateinit, msg_body)
        .end_cell();

    send_raw_message(msg, SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE | SEND_MODE_BOUNCE_ON_ACTION_FAIL);
    wl_round::ton_invested_total += user_value_after_fee;
    ;; TODO - add explanation
    public_round::synthetic_ton_reserve += user_value_after_fee;
}

() handle_public_purchase(msg_value) {

}