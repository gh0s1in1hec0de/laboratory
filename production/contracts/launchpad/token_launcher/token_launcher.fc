#include "../imports/stdlib.fc";
#include "../op-codes.fc";
#include "../workchain.fc";
#include "../utils.fc";

#include "tl_context.fc";


{-
  TODO - find out, how to handle decimals (see STON.fi core)

  sale_data# owner_limit_pct:uint8 owner_balance:Coins owner_token_price:uint32 owner_round_end_time:int32
  wl_round_end_time:int32 hamster_round_end_time:int32 = SaleData;

  storage# balance:Coins chief:MsgAddressInt creator: MsgAddressInt
  sale_data: ^SaleData metadata_uri: ^Cell = LaunchStorage;

-}

cell build_content_cell(slice metadata_uri) inline {
    cell content_dict = new_dict();
    content_dict~set_token_snake_metadata_entry("uri"H, metadata_uri);
    content_dict~set_token_snake_metadata_entry("decimals"H, "6");
    return create_token_onchain_metadata(content_dict);
}

(int, int, int, slice, slice, cell, cell, cell) load_data() inline_ref {
    slice ds = get_data().begin_parse();
    this::is_initialized = ds~load_int(1);
    this::total_supply = ds~load_coins();
    this::cur_balance = ds~load_coins();
    this::chief = ds~load_msg_addr();
    this::creator = ds~load_msg_addr();

    cell sale_config = ds~load_ref();
    sale_config::owner_balance = sale_config~load_coins();
    sale_config::owner_token_price = sale_config~load_uint(32);
    sale_config::owner_round_end_time = sale_config~load_int(32);
    sale_config::wl_round_end_time = sale_config~load_int(32);
    sale_config::hamster_round_end_time = sale_config~load_int(32);

    this::metadata_uri = ds~load_ref();
    this::user_vault_code = ds~load_ref();
    ds.end_parse();
}

() save_data() impure inline_ref {
    ;; don't forget about cell upper bound - 1023 bits
    cell sale_data = begin_cell()
        .store_uint(sale_config::owner_token_price, 8)
        .store_coins(sale_config::owner_balance)
        .store_uint(sale_config::owner_token_price, 32)
        .store_int(sale_config::owner_round_end_time, 32)
        .store_int(sale_config::wl_round_end_time, 32)
        .store_int(sale_config::hamster_round_end_time, 32)
        .end_cell();

    cell data = begin_cell()
        .store_int(this::is_initialized, 1)
        .store_coins(this::total_supply)        ;; VarUinteger16
        .store_coins(this::cur_balance)         ;; VarUinteger16
        .store_slice(this::chief)               ;; Address(267 bits - common size) todo - prove it
        .store_slice(this::creator)             ;; Address
        .store_ref(this::metadata_uri)              ;; Metadata Cell
        .store_ref(this::user_vault_code)       ;; Metadata Cell
        .end_cell();

    set_data(data);
}

() initialize(slice msg_body) impure inline {
    int total_supply = msg_body~load_coins();
    this::total_supply = total_supply;
    this::cur_balance = total_supply;

    this::chief = msg_body~load_msg_addr();
    this::creator = msg_body~load_msg_addr();

    load_sale_config(msg_body~load_ref());
    this::metadata_uri = msg_body~load_ref();
    this::user_vault_code = msg_body~load_ref();

    save_data();
}

() on_bounce(slice in_msg_body) impure inline {
    ;; gonna be filled in later
}

() recv_internal(int contract_balance, int attached_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?() | in_msg_body.slice_bits() < 32) {
        ;; TODO is `msg_body.slice_bits() < 32` really necessary?
        ;; logic for simple transfers
    }
    (int msg_flags, slice sender_address, int attached_value, int fwd_fee_from_in_msg) = extract_full_msg_data(in_msg_full);
    (int op, int query_id) = in_msg_body~load_op_and_query_id();

    if (msg_flags & 1) { ;; is bounced
        on_bounce(in_msg_body);
        return ();
    }

    ;; purified forward fee of incoming message
    ;; int fwd_fee = get_original_fwd_fee(MY_WORKCHAIN, fwd_fee_from_in_msg);
    load_data(); ;; Now we have our contract data available in globals

    if (op == op::tl::init) {
        throw_if(error::already_initialized, this::is_initialized);
        initialize(in_msg_body);
        return ();
    }
    ;; we can't perform any operations before initialization
    throw_unless(error::uninitialized, this::is_initialized);
    if (op == op::tl::creator_buyout) {
        throw_unless(error::not_owner, sender_address == this::creator);
        ;; do we really need to reserve contract funds? I mean we can just check if message value is enogh to fullfill our needs
        raw_reserve(0, RESERVE_WITH_CONTRACT_BALANCE | RESERVE_BOUNCE_ON_ACTION_FAIL); ;; seems like second one is unnecessary

        ;; parse value, lock value we need to pay fees, count tokens we need to send this guy and fucking send it, well?
        ;; TODO Do some assy-bitchie mechanism for token limit control
    }
    if (op == op::transfer_notification) { {- In fact, WL buy -} }
    if (op == op::tl::public_buy) { }

    if (op == op::excesses) { {- ??? -} }

    throw(error::wrong_op);
}

(int, slice, cell, cell) get_launch_data() method_id {
    load_data();
    throw_unless(error::uninitialized, this::is_initialized);
    return (this::total_supply, this::creator, build_content_cell(this::metadata_uri.begin_parse()), this::user_vault_code);
}
