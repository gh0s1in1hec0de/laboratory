#include "../imports/stdlib.fc";
#include "../op-codes.fc";
#include "../workchain.fc";
#include "../utils.fc";

#include "tl_context.fc";
#include "trades_handler.fc";

{-
  TODO are we doing this ton-jetton processing the correct way? mhm?

  owner round - fixed token price | fixed token limit | remainder goes to public phase
  WL Round    - firlaunch

  sale_data# owner_limit_pct:uint8 owner_balance:Coins owner_token_price:uint32 owner_round_end_time:int32
  wl_tokens_share:unt8 wl_ton_limit_pct:uint8 wl_ton_invested_total:Coins wl_round_end_time:int32
  public_synthetic_reserve_a:Coins public_synthetic_reserve_b:Coins public_round_end_time:int32 = SaleData;

  storage# balance:Coins chief:MsgAddressInt creator: MsgAddressInt
  sale_data: ^SaleData metadata_uri: ^Cell = LaunchStorage;

-}

cell build_content_cell(slice metadata_uri) inline {
    cell content_dict = new_dict();
    content_dict~set_token_snake_metadata_entry("uri"H, metadata_uri);
    content_dict~set_token_snake_metadata_entry("decimals"H, "6");
    return create_token_onchain_metadata(content_dict);
}

;; TODO add following admin options: buys freeze, sells freeeze
;; TODO should I add our jetton wallet address caching?
() load_data() inline_ref {
    slice ds = get_data().begin_parse();
    this::is_initialized? = ds~load_int(1);
    this::total_supply = ds~load_coins();
    this::cur_balance = ds~load_coins();
    this::chief = ds~load_msg_addr();
    this::creator = ds~load_msg_addr();

    cell sale_config = ds~load_ref();
    load_sale_config(sale_config);

    cell utils = ds~load_ref();
    slice utils_slice = utils.begin_parse();
    this::util_jetton_wal_addr = utils_slice~load_msg_addr();
    this::util_jetton_wal_stateinit = utils_slice~load_ref();
    this::metadata_uri = utils_slice~load_ref();
    this::user_vault_code = utils_slice~load_ref();
    utils_slice.end_parse();

    ds.end_parse();
}

() save_data() impure inline_ref {
    ;; don't forget about cell upper bound - 1023 bits
    cell sale_data = begin_cell()
        .store_uint(sale_config::creator_limit_pct, 8)
        .store_coins(sale_config::creator_balance)
        .store_uint(sale_config::creator_token_price, 32)
        .store_int(sale_config::creator_round_end_time, 32)

        .store_uint(sale_config::wl_tokens_share, 8)
        .store_uint(sale_config::wl_ton_limit_pct, 8)
        .store_coins(sale_config::wl_ton_invested_total)
        .store_int(sale_config::wl_round_end_time, 32)

        .store_coins(sale_config::public_synthetic_reserve_a)
        .store_coins(sale_config::public_synthetic_reserve_b)
        .store_int(sale_config::public_round_end_time, 32)
        .end_cell();

    cell utils = begin_cell()
        .store_slice(this::util_jetton_wal_addr)
        .store_ref(this::util_jetton_wal_stateinit)
        .store_ref(this::metadata_uri)
        .store_ref(this::user_vault_code)
        .end_cell();

    ;; 1 + 16 + 16 + 267 + 267 + 267 < 1023
    cell data = begin_cell()
        .store_int(this::is_initialized?, 1)
        .store_coins(this::total_supply)         ;; VarUinteger16
        .store_coins(this::cur_balance)          ;; VarUinteger16
        .store_slice(this::chief)                ;; address(267 bits - common size) todo - prove it
        .store_slice(this::creator)              ;; address
        .store_slice(this::util_jetton_wal_addr) ;; address
        .store_ref(sale_data)                    ;; sale parameters cell
        .store_ref(utils)
        .end_cell();

    set_data(data);
}

() initialize(slice msg_body) impure inline {
    ;; TODO early version, now does not work propoerly, rewrite at the end
    int total_supply = msg_body~load_coins();
    this::total_supply = total_supply;
    this::cur_balance = total_supply;

    this::chief = msg_body~load_msg_addr();
    this::creator = msg_body~load_msg_addr();

    load_sale_config(msg_body~load_ref());
    this::metadata_uri = msg_body~load_ref();
    this::user_vault_code = msg_body~load_ref();

    save_data();
}

() on_bounce(slice in_msg_body) impure inline {
    ;; gonna be filled in later
}

;; TODO add time constraints
() recv_internal(int contract_balance, int attached_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?() | in_msg_body.slice_bits() < 32) {
        ;; TODO is `msg_body.slice_bits() < 32` really necessary?
        ;; logic for simple transfers
    }
    (int msg_flags, slice sender_address, int attached_value, int fwd_fee_from_in_msg) = extract_full_msg_data(in_msg_full);
    (int op, int query_id) = in_msg_body~load_op_and_query_id();

    if (msg_flags & 1) { ;; is bounced
        on_bounce(in_msg_body);
        return ();
    }

    ;; purified forward fee of incoming message
    ;; int fwd_fee = get_original_fwd_fee(MY_WORKCHAIN, fwd_fee_from_in_msg);
    load_data(); ;; Now we have our contract data available in globals

    if (op == op::tl::init) {
        throw_if(error::already_initialized, this::is_initialized?);
        initialize(in_msg_body);
        return ();
    }
    ;; we can't perform any operations before initialization
    throw_unless(error::uninitialized, this::is_initialized?);
    if (op == op::tl::creator_buyout) {
        throw_unless(error::not_owner, sender_address == this::creator);
        ;; do we really need to reserve contract funds? I mean we can just check if message value is enogh to fullfill our needs
        raw_reserve(0, RESERVE_WITH_CONTRACT_BALANCE | RESERVE_BOUNCE_ON_ACTION_FAIL); ;; seems like second one is unnecessary, I mean what is the case of fail?
        handle_owner_buyout(attached_value);
        save_data();
        return ();
    }
    if (op == op::transfer_notification) {
        ;; verify, that sender is our utility token wallet and no one other
        raw_reserve(0, RESERVE_WITH_CONTRACT_BALANCE | RESERVE_BOUNCE_ON_ACTION_FAIL); ;; seems like second one is unnecessary, I mean what is the case of fail?
        handle_wl_purchase(query_id,in_msg_body~load_coins(), attached_value, sender_address, in_msg_body~load_msg_addr());
        save_data();
        return();
    }
    if (op == op::tl::public_buy) { }

    if (op == op::excesses) { {- ??? -} }

    throw(error::wrong_op);
}

(int, slice, cell, cell) get_launch_data() method_id {
    load_data();
    throw_unless(error::uninitialized, this::is_initialized?);
    return (this::total_supply, this::creator, build_content_cell(this::metadata_uri.begin_parse()), this::user_vault_code);
}
