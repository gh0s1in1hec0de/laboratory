#include "../imports/stdlib.fc";
#include "../op-codes.fc";
#include "../workchain.fc";
#include "../utils.fc";

#include "tl_context.fc";
#include "trades_handler.fc";

{-
  TODO are we doing this ton-jetton processing the correct way? mhm?

  Owner round - fixed token price | fixed token limit | remainder goes to public phase
  WL Round    - firlaunch

  sale_data# owner_limit_pct:uint8 owner_balance:Coins owner_token_price:uint32 owner_round_end_time:int32
  wl_tokens_share:unt8 wl_ton_limit_pct:uint8 wl_ton_invested_total:Coins wl_round_end_time:int32
  public_synthetic_reserve_a:Coins public_synthetic_reserve_b:Coins public_round_end_time:int32 = SaleData;

  storage# balance:Coins chief:MsgAddressInt creator: MsgAddressInt
  sale_data: ^SaleData metadata_uri: ^Cell = LaunchStorage;

-}

cell build_content_cell(slice metadata_uri) inline {
    cell content_dict = new_dict();
    content_dict~set_token_snake_metadata_entry("uri"H, metadata_uri);
    content_dict~set_token_snake_metadata_entry("decimals"H, "6");
    return create_token_onchain_metadata(content_dict);
}

;; TODO add following admin options: buys freeze, sells freeeze, util token management
;; TODO should I add our jetton wallet address caching?
() load_data() inline_ref {
    slice ds = get_data().begin_parse();
    this::const::is_initialized? = ds~load_int(1);
    this::const::total_supply = ds~load_coins();
    this::cur_balance = ds~load_coins();
    this::const::chief = ds~load_msg_addr();
    this::const::creator = ds~load_msg_addr();

    cell sale_config = ds~load_ref();
    load_sale_config(sale_config);

    cell utils = ds~load_ref();
    slice utils_slice = utils.begin_parse();
    this::const::util_jetton_wal_addr = utils_slice~load_msg_addr();
    this::const::util_jetton_wal_stateinit = utils_slice~load_ref();
    this::const::metadata_uri = utils_slice~load_ref();
    this::const::user_vault_code = utils_slice~load_ref();
    utils_slice.end_parse();

    ds.end_parse();
}

() save_data() impure inline_ref {
    ;; Don't forget about cell upper bound - 1023 bits
    ;; TODO - compress integers, where it is possible
    cell sale_data = begin_cell()
        .store_uint(creator_round::const::jet_limit, 8)
        .store_coins(creator_round::creator_jet_balance)
        .store_uint(creator_round::const::jet_price, 32)
        .store_int(creator_round::const::end_time, 32)

        .store_uint(wl_round::const::jet_limit, 8)
        .store_uint(wl_round::const::ton_limit, 8)
        .store_coins(wl_round::const::pass_min_util_jet_amount)
        .store_coins(wl_round::const::burn_util_jet_amount)
        .store_coins(wl_round::ton_invested_total)
        .store_int(wl_round::const::end_time, 32)

        .store_coins(public_round::synthetic_jet_reserve)
        .store_coins(public_round::synthetic_ton_reserve)
        .store_int(public_round::const::end_time, 32)
        .end_cell();

    cell utils = begin_cell()
        .store_slice(this::const::util_jetton_wal_addr)
        .store_ref(this::const::util_jetton_wal_stateinit)
        .store_ref(this::const::metadata_uri)
        .store_ref(this::const::user_vault_code)
        .end_cell();

    ;; 1 + 16 + 16 + 267 + 267 + 267 < 1023
    cell data = begin_cell()
        .store_int(this::const::is_initialized?, 1)
        .store_coins(this::const::total_supply)         ;; VarUinteger16
        .store_coins(this::cur_balance)                 ;; VarUinteger16
        .store_slice(this::const::chief)                ;; address(267 bits - common size) todo - prove it
        .store_slice(this::const::creator)              ;; address
        .store_slice(this::const::util_jetton_wal_addr) ;; address
        .store_ref(sale_data)                           ;; sale parameters cell
        .store_ref(utils)
        .end_cell();

    set_data(data);
}

() initialize(slice msg_body) impure inline {
    ;; TODO early version, now does not work propoerly, rewrite at the end
    int total_supply = msg_body~load_coins();
    this::const::total_supply = total_supply;
    this::cur_balance = total_supply;

    this::const::chief = msg_body~load_msg_addr();
    this::const::creator = msg_body~load_msg_addr();

    load_sale_config(msg_body~load_ref());
    this::const::metadata_uri = msg_body~load_ref();
    this::const::user_vault_code = msg_body~load_ref();

    save_data();
}

() on_bounce(slice in_msg_body) impure inline {
    ;; All balance operations revertions
}

() recv_internal(int contract_balance, int attached_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?() | in_msg_body.slice_bits() < 32) {
        ;; TODO is `msg_body.slice_bits() < 32` really necessary?
        ;; Logic for simple transfers
    }
    (int msg_flags, slice sender_address, int attached_value, int fwd_fee_from_in_msg) = extract_full_msg_data(in_msg_full);
    (int op, int query_id) = in_msg_body~load_op_and_query_id();

    if (msg_flags & 1) {
        ;; is bounced
        on_bounce(in_msg_body);
        return ();
    }

    ;; Purified forward fee of incoming message
    ;; int fwd_fee = get_original_fwd_fee(MY_WORKCHAIN, fwd_fee_from_in_msg);
    load_data(); ;; Now we have our contract data available in globals

    if (op == op::tl::init) {
        throw_if(error::already_initialized, this::const::is_initialized?);
        initialize(in_msg_body);
        return ();
    }

    ;; We can't perform any operations before initialization
    throw_unless(error::uninitialized, this::const::is_initialized?);

    if (op == op::tl::creator_buyout) {
        throw_unless(error::unauthorized_access, equal_slices_bits(sender_address, this::const::creator));
        ;; Do we really need to reserve contract funds? I mean we can just check if message value is enough to fullfill our needs
        raw_reserve(0, RESERVE_WITH_CONTRACT_BALANCE | RESERVE_BOUNCE_ON_ACTION_FAIL);
        handle_owner_buyout(attached_value);
        save_data();
        return ();
    }
    ;; We are interensted in two senders - wallet that is responsible for
    ;; our utility token and wallet, responsible for token, newly created after public round
    if (op == op::transfer_notification) {
        ;; Verify, that sender is our utility token wallet and no one other
        raw_reserve(0, RESERVE_WITH_CONTRACT_BALANCE); ;; Transfer notification can't be bounced back
        handle_wl_purchase(query_id, in_msg_body~load_coins(), attached_value, sender_address, in_msg_body~load_msg_addr());
        save_data();
        return ();
    }
    if (op == op::tl::wl_callback) {
        raw_reserve(0, RESERVE_WITH_CONTRACT_BALANCE);
        handle_wl_callback(query_id, attached_value, sender_address, in_msg_body~load_bool(), in_msg_body~load_msg_addr());
        ;; Nothing to save as no changes to state were done
        return ();
    }
    if (op == op::tl::public_buy) {
        raw_reserve(0, RESERVE_WITH_CONTRACT_BALANCE | RESERVE_BOUNCE_ON_ACTION_FAIL);
        handle_public_purchase(query_id, attached_value, sender_address);
        save_data();
        return ();
    }
    if (op == op::tl::refund_request) {
        raw_reserve(0, RESERVE_WITH_CONTRACT_BALANCE | RESERVE_BOUNCE_ON_ACTION_FAIL);
        handle_refund_request(query_id, attached_value, sender_address, in_msg_body~load_uint(4), in_msg_body~load_coins());
        return ();
    }
    if (op == op::tl::refund_confirmation) {
        handle_refund_confirmation();
        save_data();
        return ();
    }

    if (op == op::tl::claim_jettons) {

    }

    ;; Should I change it somehow?
    if (op == op::excesses) {
        return ();
    }

    throw(error::wrong_op);
}

(int, slice, cell, cell) get_launch_data() method_id {
    load_data();
    throw_unless(error::uninitialized, this::const::is_initialized?);
    return (this::const::total_supply, this::const::creator, build_content_cell(this::const::metadata_uri.begin_parse()), this::const::user_vault_code);
}
