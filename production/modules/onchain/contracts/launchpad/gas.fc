#include "../workchain.fc";
#include "../stdlib.fc";
#include "op-codes.fc";

const ONE_TON = 1000000000;
const 1_MONTH = 30 * 24 * 3600;
const 2_MONTHS = 60 * 24 * 3600;

;; Precompiled constants
;; All of the contents are result of contract emulation tests

;; Minimal fees
;; https://github.com/ton-blockchain/stablecoin-contract/blob/62f661d79012a259c0110dce611dafc31359be78/contracts/gas.fc#L14 (Actuallly 28627415, but rounded)
const JETTON_MIN_TRANSFER_FEE = 30000000;
;; https://docs.ton.org/develop/smart-contracts/fees#fees-for-sending-ton
const SIMPLE_TRANSFER_FEE = 6000000;

const USER_VAULT_BITS  = 1;
const USER_VAULT_CELLS = 1;
const TOKEN_LAUNCH_BITS  = 1;
const TOKEN_LAUNCH_CELLS = 1;

const USER_VAULT_INITSTATE_BITS  = 1;
const USER_VAULT_INITSTATE_CELLS = 1;

const JETTON_MINTER_INITSTATE_BITS = 1;
const JETTON_MINTER_INITSTATE_CELLS = 1;

;; Loaded storage upper bounds, TODO replace with deployed stats if needed
const TOKEN_LAUNCH_INITSTATE_BITS = 48441;
const TOKEN_LAUNCH_INITSTATE_CELLS = 120;

;; Message that contains info about user's balance updates
const BALANCE_UPDATE_MSG_BITS = 1;
const BALANCE_UPDATE_MSG_CELLS = 1;
;; Both - refund and claim confirmation message - they differ by op, but have the same structure and info
const WITHDRAW_CONFIRMATION_MSG_BITS = 1;
const WITHDRAW_CONFIRMATION_MSG_CELLS = 1;
;; Claim request to user vault
const CLAIM_MSG_BITS = 1;
const CLAIM_MSG_CELLS = 1;

;; file#L`line_num` - maunal bits counting
const BALANCE_UPDATE_BITS = 1; ;; estimation looks like: body = 32+64+124+(3+8+256)+(3+8+256)
const BALANCE_UPDATE_CELLS = 1; ;; body always in ref

;; file#L`line_num` - maunal bits counting
const WL_CALLBACK_MSG_BITS = 1; ;; estimation looks like: body = 32+64+124+(3+8+256)+(3+8+256)
const WL_CALLBACK_MSG_CELLS = 1; ;; body always in ref

;; Gas
;; Gas constants are calculated in the main test suite.
;; First the related transaction is found, and then it's
;; resulting gas consumption is printed to the console.

const RECEIVE_BALANCE_UPDATE_CONSUMPTION = 1;
const RECEIVE_CLAIM_CONSUMPTION = 1;

int calculate_user_vault_min_storage_fee() inline {
    return get_storage_fee(MY_WORKCHAIN, 2_MONTHS, USER_VAULT_BITS, USER_VAULT_CELLS);
}

int calculate_token_launch_min_storage_fee(int duration) inline {
    return get_storage_fee(MY_WORKCHAIN, duration, TOKEN_LAUNCH_BITS, TOKEN_LAUNCH_CELLS);
}

int forward_user_vault_init_state_overhead() inline {
    return get_simple_forward_fee(MY_WORKCHAIN, USER_VAULT_INITSTATE_BITS, USER_VAULT_INITSTATE_CELLS);
}

int forward_jetton_minter_init_state_overhead() inline {
    return get_simple_forward_fee(MY_WORKCHAIN, JETTON_MINTER_INITSTATE_BITS, JETTON_MINTER_INITSTATE_CELLS);
}

int forward_token_launch_init_state_overhead() inline {
    return get_simple_forward_fee(MY_WORKCHAIN, TOKEN_LAUNCH_INITSTATE_BITS, TOKEN_LAUNCH_INITSTATE_CELLS);
}

;;; Accounts unified balance-update message forwarding, user vault stateinit & storage fee overhead
;;; and receiving balance update gas consumption
int get_balance_update_gas_cost() inline_ref {
    return
    get_forward_fee(MY_WORKCHAIN, BALANCE_UPDATE_MSG_BITS, BALANCE_UPDATE_MSG_CELLS)
    + forward_user_vault_init_state_overhead()
    ;; + get_compute_fee(MY_WORKCHAIN, SEND_BALANCE_UPDATE_CONSUMPTION)
    ;; TODO Does it always consume the same amount of gas? Seems like all the values are close, so we may take the upper bound (but now fees are separate)
    + get_compute_fee(MY_WORKCHAIN, RECEIVE_BALANCE_UPDATE_CONSUMPTION)
    + calculate_user_vault_min_storage_fee();
}

;;; Returns purified value and operational needs
(int, int) validate_value(int total, int fee) inline_ref {
    throw_if(error::not_enough_gas, fee > total);
    int extra = total - fee;
    int purified = muldiv(extra, 99, 100);
    throw_unless(error::balance_lack, purified > 0);
    return (purified, extra - purified);
}

;; As we don't have any external calls, we accounting only code execution fees
const CREATOR_BUYOUT_GAS_CONSUMPTION = 1;
(int, int) check_amount_is_enough_for_creator_buyout(int msg_value) inline {
    int fee = get_compute_fee(MY_WORKCHAIN, CREATOR_BUYOUT_GAS_CONSUMPTION);
    return validate_value(msg_value, fee);
}

;; === Whitelist Purchase ===
const WL_PURCHASE_GAS_CONSUMPTION = 1;
const WL_CALLBACK_GAS_CONSUMPTION = 1;
int get_wl_purchase_gas_consumption() inline_ref {
    return get_compute_fee(MY_WORKCHAIN, WL_PURCHASE_GAS_CONSUMPTION)
    + get_balance_update_gas_cost()
    + get_forward_fee(MY_WORKCHAIN, WL_CALLBACK_MSG_BITS, WL_CALLBACK_MSG_CELLS)
    + get_compute_fee(MY_WORKCHAIN, WL_CALLBACK_GAS_CONSUMPTION);
}

(int, int) check_amount_is_enough_for_wl_purchase(int msg_value) inline {
    ;; Don't use throw here as we have to return tokens back in case of errors
    (int validated, int opn) = (0, 0);
    try {
        (validated, opn) = validate_value(msg_value, get_wl_purchase_gas_consumption());
    } catch (_, _) {
        ;; Nothing to catch here, so I'll just leave some meows:
        ;; meow meow meow
    }
    return (validated, opn);
}

;; === Public Purchase ===
const PUB_PURCHASE_GAS_CONSUMPTION = 1;
(int, int) check_amount_is_enough_for_public_purchase(int msg_value) {
    return validate_value(
        msg_value,
        get_compute_fee(MY_WORKCHAIN, PUB_PURCHASE_GAS_CONSUMPTION) + get_balance_update_gas_cost()
    );
}

;; === Refund ===
const REFUND_REQUEST_GAS_CONSUMPTION = 1;
const REFUND_CONFIRMATION_GAS_CONSUMPTION = 1;
() check_amount_is_enough_for_refund(int msg_value) {
    int required_gas =
    get_compute_fee(MY_WORKCHAIN, REFUND_REQUEST_GAS_CONSUMPTION)
    + get_balance_update_gas_cost()
    + get_forward_fee(MY_WORKCHAIN, WITHDRAW_CONFIRMATION_MSG_BITS, WITHDRAW_CONFIRMATION_MSG_CELLS)
    + get_compute_fee(MY_WORKCHAIN, REFUND_CONFIRMATION_GAS_CONSUMPTION)
    + SIMPLE_TRANSFER_FEE;
    throw_if(error::not_enough_gas, msg_value < required_gas);
}

;; === Token Deploy ===
const DEPLOY_JETTON_GAS_CONSUMPTION = 1; ;; This is code we call on token launch's side
const MINT_MSG_BITS = 1;
const MINT_MSG_CELLS = 1;
const MINT_GAS_CONSUMPTION = 1;
const ACCEPT_MINTED_JETTONS_GAS_CONSUMPTION = 1;
;; See jetton_operating.fc#L103
const JETTON_TRANSFER_FORWARD_PAYLOAD_BITS = 1;
const JETTON_TRANSFER_FORWARD_PAYLOAD_CELLS = 1;
const CLAIM_ADMIN_MSG_BITS = 1;
const CLAIM_ADMIN_MSG_CELLS = 1;
const CLAIM_ADMIN_GAS_CONSUMPTION = 1;
;;; Warning! This function does not include computation fee on token launch's side
int get_jetton_deploy_gas_cost() {
    return get_forward_fee(MY_WORKCHAIN, MINT_MSG_BITS, MINT_MSG_CELLS)
    + forward_jetton_minter_init_state_overhead()
    + get_compute_fee(MY_WORKCHAIN, MINT_GAS_CONSUMPTION)
    + JETTON_MIN_TRANSFER_FEE * 2 ;; Multiply on 2 as we send DEX part of tokens to chief in the same operation
    + get_forward_fee(MY_WORKCHAIN, JETTON_TRANSFER_FORWARD_PAYLOAD_BITS, JETTON_TRANSFER_FORWARD_PAYLOAD_CELLS)
    + get_forward_fee(MY_WORKCHAIN, CLAIM_ADMIN_MSG_BITS, CLAIM_ADMIN_MSG_CELLS)
    + get_compute_fee(MY_WORKCHAIN, CLAIM_ADMIN_GAS_CONSUMPTION);
}

;; === Jetton Claim ===

;; Don't need stateinit as if vault doesn't exist, then there is nothing to claim
int get_claim_gas_cost() inline_ref {
    return
    ;; Forwarding claim message
     get_forward_fee(MY_WORKCHAIN, CLAIM_MSG_BITS, CLAIM_MSG_CELLS)
    ;; User-vault side request processing
    + get_compute_fee(MY_WORKCHAIN, RECEIVE_CLAIM_CONSUMPTION)
    + calculate_user_vault_min_storage_fee();
}
const CLAIM_GAS_CONSUMPTION = 1;
const CLAIM_CONFIRMATION_GAS_CONSUMPTION = 1;
int check_amount_is_enough_for_jetton_claim(int msg_value) {
    int required_gas =
    ;; Our side request processing
    get_compute_fee(MY_WORKCHAIN, CLAIM_GAS_CONSUMPTION)
    ;; Forwarding claim message
    + get_claim_gas_cost()
    ;; User vault's response
    + get_forward_fee(MY_WORKCHAIN, WITHDRAW_CONFIRMATION_MSG_BITS, WITHDRAW_CONFIRMATION_MSG_CELLS)
    ;; Our side callback processing
    + get_compute_fee(MY_WORKCHAIN, CLAIM_CONFIRMATION_GAS_CONSUMPTION)
    ;; Transfering resulted jettons to user
    + JETTON_MIN_TRANSFER_FEE;
    throw_unless(error::not_enough_gas, msg_value > required_gas);
    return msg_value - required_gas;
}

;; Creation of a new token launch
const CREATE_LAUNCH_GAS_CONSUMPTION = 1;
const INIT_MSG_BITS = 1;
const INIT_MSG_CELLS = 1;
const INITIALIZATION_GAS_CONSUMPTION = 15217;
;; Body contains only OP
const INIT_CALLBACK_MSG_BITS = 1;
const INIT_CALLBACK_MSG_CELLS = 1;
const INIT_CALLBACK_GAS_CONSUMPTION = 1;
const RECORD_REWARD_JETTONS_ENROLLMENT_GAS_CONSUMPTION = 1;
int get_amount_for_token_launch_deploy() {
    return get_compute_fee(MY_WORKCHAIN, CREATE_LAUNCH_GAS_CONSUMPTION)
        + get_forward_fee(MY_WORKCHAIN, INIT_MSG_BITS, INIT_MSG_CELLS)
        + calculate_token_launch_min_storage_fee(2_MONTHS)
        + forward_token_launch_init_state_overhead()
        + get_compute_fee(MY_WORKCHAIN, INITIALIZATION_GAS_CONSUMPTION)
        + get_forward_fee(MY_WORKCHAIN, INIT_CALLBACK_MSG_BITS, INIT_CALLBACK_MSG_CELLS)
        + get_compute_fee(MY_WORKCHAIN, INIT_CALLBACK_GAS_CONSUMPTION)
        + JETTON_MIN_TRANSFER_FEE
        + get_compute_fee(MY_WORKCHAIN, RECORD_REWARD_JETTONS_ENROLLMENT_GAS_CONSUMPTION)
        ;; Creator of new token launch should pay for the future jetton deployment
        + get_compute_fee(MY_WORKCHAIN, DEPLOY_JETTON_GAS_CONSUMPTION)
        + get_jetton_deploy_gas_cost();
}